<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cMsg Messaging System: cMsg.c File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cMsg Messaging System
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d6/de2/c_msg_8c.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cMsg.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;strings.h&gt;</code><br />
<code>#include &lt;dlfcn.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &quot;cMsgNetwork.h&quot;</code><br />
<code>#include &quot;cMsgPrivate.h&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d5/d52/c_msg_8h_source.html">cMsg.h</a>&quot;</code><br />
<code>#include &quot;cMsgRegex.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a88ac8658ddc9211f67247f7e72c1950c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>&#160;&#160;&#160;200</td></tr>
<tr class="separator:a88ac8658ddc9211f67247f7e72c1950c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ce36916c399104e18d32ff090f21c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a58ce36916c399104e18d32ff090f21c6">MAX_STR_LEN</a>&#160;&#160;&#160;2000</td></tr>
<tr class="separator:a58ce36916c399104e18d32ff090f21c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5510f92d0e9c27ce594d9612eda88975"><td class="memItemLeft" align="right" valign="top">typedef struct parsedUDL_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a5510f92d0e9c27ce594d9612eda88975">parsedUDL</a></td></tr>
<tr class="separator:a5510f92d0e9c27ce594d9612eda88975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a04b867224188eca1aa6f9c61ba868adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a04b867224188eca1aa6f9c61ba868adb">cMsgTrim</a> (char *s)</td></tr>
<tr class="separator:a04b867224188eca1aa6f9c61ba868adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1726f9ebefe2199ac38a60e35e0e1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ad1726f9ebefe2199ac38a60e35e0e1c7">cMsgTrimChar</a> (char *s, char trimChar)</td></tr>
<tr class="separator:ad1726f9ebefe2199ac38a60e35e0e1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0620f042ef32f864ed34dd47b9531ea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a0620f042ef32f864ed34dd47b9531ea7">cMsgTrimDoubleChars</a> (char *s, char trimChar)</td></tr>
<tr class="separator:a0620f042ef32f864ed34dd47b9531ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d77690be8974fa96f871258b78ea538"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a0d77690be8974fa96f871258b78ea538">strndup</a> (const char *s1, size_t count)</td></tr>
<tr class="separator:a0d77690be8974fa96f871258b78ea538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd14b7dbe6db6fa21f267f0d75ba78b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#afbd14b7dbe6db6fa21f267f0d75ba78b">cMsgSetUDL</a> (void *domainId, const char *UDL)</td></tr>
<tr class="separator:afbd14b7dbe6db6fa21f267f0d75ba78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1b1b374341bb88557fc26b32c3054c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aff1b1b374341bb88557fc26b32c3054c">cMsgGetCurrentUDL</a> (void *domainId, const char **udl)</td></tr>
<tr class="separator:aff1b1b374341bb88557fc26b32c3054c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2487f6d2221f988e2b0dca1b3004cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#adb2487f6d2221f988e2b0dca1b3004cd">cMsgGetServerHost</a> (void *domainId, const char **ipAddress)</td></tr>
<tr class="separator:adb2487f6d2221f988e2b0dca1b3004cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fb1e1c06d2296e4c39e1ef388311c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae0fb1e1c06d2296e4c39e1ef388311c2">cMsgGetServerPort</a> (void *domainId, int *port)</td></tr>
<tr class="separator:ae0fb1e1c06d2296e4c39e1ef388311c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f251bf48c97c7822b5ca1a91bd620e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a57f251bf48c97c7822b5ca1a91bd620e">cMsgGetInfo</a> (void *domainId, const char *command, char **string)</td></tr>
<tr class="separator:a57f251bf48c97c7822b5ca1a91bd620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8551bd36bdc8138c0c9574daa3d1fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#acc8551bd36bdc8138c0c9574daa3d1fc">cMsgConnect</a> (const char *myUDL, const char *myName, const char *myDescription, void **domainId)</td></tr>
<tr class="separator:acc8551bd36bdc8138c0c9574daa3d1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790114f9c2091b5c2ff12774e6790ec5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a790114f9c2091b5c2ff12774e6790ec5">cMsgReconnect</a> (void *domainId)</td></tr>
<tr class="separator:a790114f9c2091b5c2ff12774e6790ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b9114fb29704d0e2d64c22e6287adc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect</a> (void **domainId)</td></tr>
<tr class="separator:a86b9114fb29704d0e2d64c22e6287adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e85fe096860040adfeed9a8fffe175"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ac0e85fe096860040adfeed9a8fffe175">cMsgSend</a> (void *domainId, void *msg)</td></tr>
<tr class="separator:ac0e85fe096860040adfeed9a8fffe175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6d501ff5422314b650bd8c55f6f800"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a3e6d501ff5422314b650bd8c55f6f800">cMsgSyncSend</a> (void *domainId, void *msg, const struct timespec *timeout, int *response)</td></tr>
<tr class="separator:a3e6d501ff5422314b650bd8c55f6f800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab9134878cc0058e9ae3128a445ff00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#adab9134878cc0058e9ae3128a445ff00">cMsgFlush</a> (void *domainId, const struct timespec *timeout)</td></tr>
<tr class="separator:adab9134878cc0058e9ae3128a445ff00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d422d9f2f693414868af48a16d13649"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a5d422d9f2f693414868af48a16d13649">cMsgSubscribe</a> (void *domainId, const char *subject, const char *type, <a class="el" href="../../d5/d52/c_msg_8h.html#a2a5df4825a5a9beee6877d4e3c96f491">cMsgCallbackFunc</a> *callback, void *userArg, <a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, void **handle)</td></tr>
<tr class="separator:a5d422d9f2f693414868af48a16d13649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dab146eac57f2bd20f79628336c28b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ac1dab146eac57f2bd20f79628336c28b">cMsgUnSubscribe</a> (void *domainId, void *handle)</td></tr>
<tr class="separator:ac1dab146eac57f2bd20f79628336c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267a55c66e6d13123ffc0dbcd6b541d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a267a55c66e6d13123ffc0dbcd6b541d4">cMsgSubscriptionPause</a> (void *domainId, void *handle)</td></tr>
<tr class="separator:a267a55c66e6d13123ffc0dbcd6b541d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ee2459ff5f317674b7ea9e8df34d0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a07ee2459ff5f317674b7ea9e8df34d0a">cMsgSubscriptionResume</a> (void *domainId, void *handle)</td></tr>
<tr class="separator:a07ee2459ff5f317674b7ea9e8df34d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536677299fa10fc48bbcda4870ca441c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a536677299fa10fc48bbcda4870ca441c">cMsgSubscriptionQueueCount</a> (void *domainId, void *handle, int *count)</td></tr>
<tr class="separator:a536677299fa10fc48bbcda4870ca441c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6442b2ebbc21f2e03e46722117c5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a78c6442b2ebbc21f2e03e46722117c5f">cMsgSubscriptionQueueIsFull</a> (void *domainId, void *handle, int *full)</td></tr>
<tr class="separator:a78c6442b2ebbc21f2e03e46722117c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20b7dedc9fe1cea771b46d6ac33c237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ab20b7dedc9fe1cea771b46d6ac33c237">cMsgSubscriptionQueueClear</a> (void *domainId, void *handle)</td></tr>
<tr class="separator:ab20b7dedc9fe1cea771b46d6ac33c237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249f6269c777aacf10732643d1d3ecc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a249f6269c777aacf10732643d1d3ecc7">cMsgSubscriptionMessagesTotal</a> (void *domainId, void *handle, int *total)</td></tr>
<tr class="separator:a249f6269c777aacf10732643d1d3ecc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b774e764c900e8f742102923642950"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ad7b774e764c900e8f742102923642950">cMsgSendAndGet</a> (void *domainId, void *sendMsg, const struct timespec *timeout, void **replyMsg)</td></tr>
<tr class="separator:ad7b774e764c900e8f742102923642950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a497a089d800a0fb05a27d3e736e8c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a7a497a089d800a0fb05a27d3e736e8c1">cMsgSubscribeAndGet</a> (void *domainId, const char *subject, const char *type, const struct timespec *timeout, void **replyMsg)</td></tr>
<tr class="separator:a7a497a089d800a0fb05a27d3e736e8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01d705dd17d13231b8128c9767311fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ad01d705dd17d13231b8128c9767311fa">cMsgMonitor</a> (void *domainId, const char *command, void **replyMsg)</td></tr>
<tr class="separator:ad01d705dd17d13231b8128c9767311fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2d833b870683ee4c130056f4d12673"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aca2d833b870683ee4c130056f4d12673">cMsgReceiveStart</a> (void *domainId)</td></tr>
<tr class="separator:aca2d833b870683ee4c130056f4d12673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6e3eb577613c7329f7518e74d0b3f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a1e6e3eb577613c7329f7518e74d0b3f7">cMsgReceiveStop</a> (void *domainId)</td></tr>
<tr class="separator:a1e6e3eb577613c7329f7518e74d0b3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a307fac8a81b863c9fcb57e30b8c045"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a7a307fac8a81b863c9fcb57e30b8c045">cMsgGetConnectState</a> (void *domainId, int *connected)</td></tr>
<tr class="separator:a7a307fac8a81b863c9fcb57e30b8c045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe6ba7c854be09a2362f22eeb44e194"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a4fe6ba7c854be09a2362f22eeb44e194">cMsgSetShutdownHandler</a> (void *domainId, <a class="el" href="../../d5/d52/c_msg_8h.html#a13c894556c5124a6f408f1b5266b414d">cMsgShutdownHandler</a> *handler, void *userArg)</td></tr>
<tr class="separator:a4fe6ba7c854be09a2362f22eeb44e194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa4d67ad8d8fade9360751b919e23be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#abaa4d67ad8d8fade9360751b919e23be">cMsgShutdownClients</a> (void *domainId, const char *client, int flag)</td></tr>
<tr class="separator:abaa4d67ad8d8fade9360751b919e23be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7417c11023fa420004ba20da9b710bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ab7417c11023fa420004ba20da9b710bc">cMsgShutdownServers</a> (void *domainId, const char *server, int flag)</td></tr>
<tr class="separator:ab7417c11023fa420004ba20da9b710bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81590fa3f03c5ffdc3faed419dc3cdb9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a81590fa3f03c5ffdc3faed419dc3cdb9">cMsgPerror</a> (int error)</td></tr>
<tr class="separator:a81590fa3f03c5ffdc3faed419dc3cdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43c67e4ed6b1f7118344ac9d5321e07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae43c67e4ed6b1f7118344ac9d5321e07">cMsgSetDebugLevel</a> (int level)</td></tr>
<tr class="separator:ae43c67e4ed6b1f7118344ac9d5321e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8900e00f1d6651aa96547b19e2fb0005"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a8900e00f1d6651aa96547b19e2fb0005">cMsgGetUDL</a> (void *domainId, char **udl)</td></tr>
<tr class="separator:a8900e00f1d6651aa96547b19e2fb0005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9b5fe19b27451658aefbb62f0f138b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a7c9b5fe19b27451658aefbb62f0f138b">cMsgGetName</a> (void *domainId, char **name)</td></tr>
<tr class="separator:a7c9b5fe19b27451658aefbb62f0f138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1820f554cad254ee20a559a409c47725"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a1820f554cad254ee20a559a409c47725">cMsgGetDescription</a> (void *domainId, char **description)</td></tr>
<tr class="separator:a1820f554cad254ee20a559a409c47725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9945b6ed528879a54cbc0611373a8f71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a9945b6ed528879a54cbc0611373a8f71">cMsgGetReceiveState</a> (void *domainId, int *receiveState)</td></tr>
<tr class="separator:a9945b6ed528879a54cbc0611373a8f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f804fe6777fdc77fbd35fceac93bdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage</a> (void **vmsg)</td></tr>
<tr class="separator:ad5f804fe6777fdc77fbd35fceac93bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ee42d5511e7fd79166c52d8d3658c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ad2ee42d5511e7fd79166c52d8d3658c1">cMsgFreeMessage_r</a> (void **vmsg)</td></tr>
<tr class="separator:ad2ee42d5511e7fd79166c52d8d3658c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bb3706d4c1cf31e44f1f9f1ccb78de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a77bb3706d4c1cf31e44f1f9f1ccb78de">cMsgCopyMessage</a> (const void *vmsg)</td></tr>
<tr class="separator:a77bb3706d4c1cf31e44f1f9f1ccb78de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8ef09efaaacfb7c007a8aeead0d103"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aae8ef09efaaacfb7c007a8aeead0d103">cMsgInitMessage</a> (void *vmsg)</td></tr>
<tr class="separator:aae8ef09efaaacfb7c007a8aeead0d103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e3ca9feea4b9cdd4f5d5bc144b57ce"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage</a> (void)</td></tr>
<tr class="separator:a06e3ca9feea4b9cdd4f5d5bc144b57ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f976f80a20b3e5c2a64dd9da0a2648a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a2f976f80a20b3e5c2a64dd9da0a2648a">cMsgCreateNewMessage</a> (const void *vmsg)</td></tr>
<tr class="separator:a2f976f80a20b3e5c2a64dd9da0a2648a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f2a3e781de0f85bfb16c4cfb9dba3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a1e3f2a3e781de0f85bfb16c4cfb9dba3">cMsgCreateResponseMessage</a> (const void *vmsg)</td></tr>
<tr class="separator:a1e3f2a3e781de0f85bfb16c4cfb9dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce032c8bdf39718197d7d6d2f9914d0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a5ce032c8bdf39718197d7d6d2f9914d0">cMsgCreateNullResponseMessage</a> (const void *vmsg)</td></tr>
<tr class="separator:a5ce032c8bdf39718197d7d6d2f9914d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1e33b4645d96f5746fc496b9dff35c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#adc1e33b4645d96f5746fc496b9dff35c">cMsgGetHistoryLengthMax</a> (const void *vmsg, int *len)</td></tr>
<tr class="separator:adc1e33b4645d96f5746fc496b9dff35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4d353630206fa691bdb413eafe5d35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aca4d353630206fa691bdb413eafe5d35">cMsgSetHistoryLengthMax</a> (void *vmsg, int len)</td></tr>
<tr class="separator:aca4d353630206fa691bdb413eafe5d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375ef62e93bf9feb7195abd9257d11bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a375ef62e93bf9feb7195abd9257d11bb">cMsgWasSent</a> (const void *vmsg, int *hasBeenSent)</td></tr>
<tr class="separator:a375ef62e93bf9feb7195abd9257d11bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7995e48e5e280e505e37b4b5b72402c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ad7995e48e5e280e505e37b4b5b72402c">cMsgGetVersion</a> (const void *vmsg, int *version)</td></tr>
<tr class="separator:ad7995e48e5e280e505e37b4b5b72402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2bb01b48637157ccfb8df116a45664"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a6a2bb01b48637157ccfb8df116a45664">cMsgSetGetResponse</a> (void *vmsg, int getResponse)</td></tr>
<tr class="separator:a6a2bb01b48637157ccfb8df116a45664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaa825de16af9f161cba410e0c91f74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#acdaa825de16af9f161cba410e0c91f74">cMsgGetGetResponse</a> (const void *vmsg, int *getResponse)</td></tr>
<tr class="separator:acdaa825de16af9f161cba410e0c91f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5083e7b37722212b9eb94ff6f13753b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a5083e7b37722212b9eb94ff6f13753b3">cMsgSetNullGetResponse</a> (void *vmsg, int nullGetResponse)</td></tr>
<tr class="separator:a5083e7b37722212b9eb94ff6f13753b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b25010d5d27303d15288212e018a6c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a2b25010d5d27303d15288212e018a6c2">cMsgGetNullGetResponse</a> (const void *vmsg, int *nullGetResponse)</td></tr>
<tr class="separator:a2b25010d5d27303d15288212e018a6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e02fcce345ec42440fc3ebc4c8881e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae0e02fcce345ec42440fc3ebc4c8881e">cMsgGetGetRequest</a> (const void *vmsg, int *getRequest)</td></tr>
<tr class="separator:ae0e02fcce345ec42440fc3ebc4c8881e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ecf71837d95900cf511c9d0cd1f397"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a63ecf71837d95900cf511c9d0cd1f397">cMsgGetDomain</a> (const void *vmsg, const char **domain)</td></tr>
<tr class="separator:a63ecf71837d95900cf511c9d0cd1f397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c0eac1762db63b9e0507ea6204df47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae9c0eac1762db63b9e0507ea6204df47">cMsgGetPayloadText</a> (const void *vmsg, const char **payloadText)</td></tr>
<tr class="separator:ae9c0eac1762db63b9e0507ea6204df47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890729efc8b63d8af59e54f98298ac3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a890729efc8b63d8af59e54f98298ac3c">cMsgSetSubject</a> (void *vmsg, const char *subject)</td></tr>
<tr class="separator:a890729efc8b63d8af59e54f98298ac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd99fe965b1a18f041853f167e41d67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aebd99fe965b1a18f041853f167e41d67">cMsgGetSubject</a> (const void *vmsg, const char **subject)</td></tr>
<tr class="separator:aebd99fe965b1a18f041853f167e41d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed62a8b39b6992c56bf9cdbfb00f80f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a2ed62a8b39b6992c56bf9cdbfb00f80f">cMsgSetType</a> (void *vmsg, const char *type)</td></tr>
<tr class="separator:a2ed62a8b39b6992c56bf9cdbfb00f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5079c24edb7c920c07c6e24c1e4908f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ac5079c24edb7c920c07c6e24c1e4908f">cMsgGetType</a> (const void *vmsg, const char **type)</td></tr>
<tr class="separator:ac5079c24edb7c920c07c6e24c1e4908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263231aeceba900e26f4b09f7d88f00a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a263231aeceba900e26f4b09f7d88f00a">cMsgSetText</a> (void *vmsg, const char *text)</td></tr>
<tr class="separator:a263231aeceba900e26f4b09f7d88f00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6b173d6ee98259bd9e2e3aeb9e1a34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a1e6b173d6ee98259bd9e2e3aeb9e1a34">cMsgGetText</a> (const void *vmsg, const char **text)</td></tr>
<tr class="separator:a1e6b173d6ee98259bd9e2e3aeb9e1a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4c719e852b925e02cc43dc0c0a8c3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#afc4c719e852b925e02cc43dc0c0a8c3e">cMsgSetUserInt</a> (void *vmsg, int userInt)</td></tr>
<tr class="separator:afc4c719e852b925e02cc43dc0c0a8c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a6252706b0202d3920b8a78d6629f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a77a6252706b0202d3920b8a78d6629f0">cMsgGetUserInt</a> (const void *vmsg, int *userInt)</td></tr>
<tr class="separator:a77a6252706b0202d3920b8a78d6629f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8bbb7c3868d0b1c53721ea2c48683a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aaa8bbb7c3868d0b1c53721ea2c48683a">cMsgSetUserTime</a> (void *vmsg, const struct timespec *userTime)</td></tr>
<tr class="separator:aaa8bbb7c3868d0b1c53721ea2c48683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae709e7079a007ee88ebc0b41a4da8a7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae709e7079a007ee88ebc0b41a4da8a7b">cMsgGetUserTime</a> (const void *vmsg, struct timespec *userTime)</td></tr>
<tr class="separator:ae709e7079a007ee88ebc0b41a4da8a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549e77f6cc3fd844ecec74185a5c5551"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a549e77f6cc3fd844ecec74185a5c5551">cMsgSetByteArrayEndian</a> (void *vmsg, int endian)</td></tr>
<tr class="separator:a549e77f6cc3fd844ecec74185a5c5551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118367970210f0d7b28f7c5cad6f9115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a118367970210f0d7b28f7c5cad6f9115">cMsgGetByteArrayEndian</a> (const void *vmsg, int *endian)</td></tr>
<tr class="separator:a118367970210f0d7b28f7c5cad6f9115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7679f62347f3d049024cd767da4cbbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a7679f62347f3d049024cd767da4cbbcb">cMsgNeedToSwap</a> (const void *vmsg, int *swap)</td></tr>
<tr class="separator:a7679f62347f3d049024cd767da4cbbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b957b96d5723aeaae1b63a4075069d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a6b957b96d5723aeaae1b63a4075069d4">cMsgSetByteArrayLength</a> (void *vmsg, int length)</td></tr>
<tr class="separator:a6b957b96d5723aeaae1b63a4075069d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75519fd0576e1cc7ef8ff9eb333b7bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae75519fd0576e1cc7ef8ff9eb333b7bd">cMsgResetByteArrayLength</a> (void *vmsg)</td></tr>
<tr class="separator:ae75519fd0576e1cc7ef8ff9eb333b7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086309234f06d80deccb0b8229d22a6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a086309234f06d80deccb0b8229d22a6b">cMsgGetByteArrayLength</a> (const void *vmsg, int *length)</td></tr>
<tr class="separator:a086309234f06d80deccb0b8229d22a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f394c8f794a935d32377cfa4827591"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aa2f394c8f794a935d32377cfa4827591">cMsgGetByteArrayLengthFull</a> (const void *vmsg, int *length)</td></tr>
<tr class="separator:aa2f394c8f794a935d32377cfa4827591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82750dc5dcbb0630db7b9827190b8833"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a82750dc5dcbb0630db7b9827190b8833">cMsgSetByteArrayOffset</a> (void *vmsg, int offset)</td></tr>
<tr class="separator:a82750dc5dcbb0630db7b9827190b8833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c298192a9c6ac566e0a5094c98f68d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a0c298192a9c6ac566e0a5094c98f68d0">cMsgGetByteArrayOffset</a> (const void *vmsg, int *offset)</td></tr>
<tr class="separator:a0c298192a9c6ac566e0a5094c98f68d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51659c0d03d14d540d426a96e661800"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#af51659c0d03d14d540d426a96e661800">cMsgSetByteArrayNoCopy</a> (void *vmsg, char *array, int length)</td></tr>
<tr class="separator:af51659c0d03d14d540d426a96e661800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b3d5d8af3c3f81a74ad0e27d74ef8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae7b3d5d8af3c3f81a74ad0e27d74ef8f">cMsgSetByteArray</a> (void *vmsg, char *array, int length)</td></tr>
<tr class="separator:ae7b3d5d8af3c3f81a74ad0e27d74ef8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c3d89bdcb1c8dd313bff4127e84daa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae3c3d89bdcb1c8dd313bff4127e84daa">cMsgGetByteArray</a> (const void *vmsg, char **array)</td></tr>
<tr class="separator:ae3c3d89bdcb1c8dd313bff4127e84daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0969391dfcd3cd8289eb04fc6399b602"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a0969391dfcd3cd8289eb04fc6399b602">cMsgGetSender</a> (const void *vmsg, const char **sender)</td></tr>
<tr class="separator:a0969391dfcd3cd8289eb04fc6399b602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65857ff0e87362d5098ca5e7c63961d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aa65857ff0e87362d5098ca5e7c63961d">cMsgGetSenderHost</a> (const void *vmsg, const char **senderHost)</td></tr>
<tr class="separator:aa65857ff0e87362d5098ca5e7c63961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d3b1e0b664616cb77b6966e0dce97e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ac2d3b1e0b664616cb77b6966e0dce97e">cMsgGetSenderTime</a> (const void *vmsg, struct timespec *senderTime)</td></tr>
<tr class="separator:ac2d3b1e0b664616cb77b6966e0dce97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ea9c810a5e21db3fc7ee2a70c1fdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ab74ea9c810a5e21db3fc7ee2a70c1fdd">cMsgGetReceiver</a> (const void *vmsg, const char **receiver)</td></tr>
<tr class="separator:ab74ea9c810a5e21db3fc7ee2a70c1fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af610fc6f5b12d664021f9bbddd83737c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#af610fc6f5b12d664021f9bbddd83737c">cMsgGetReceiverHost</a> (const void *vmsg, const char **receiverHost)</td></tr>
<tr class="separator:af610fc6f5b12d664021f9bbddd83737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5743b6b3fd75506c9ad40a0e840909d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a5743b6b3fd75506c9ad40a0e840909d2">cMsgGetReceiverTime</a> (const void *vmsg, struct timespec *receiverTime)</td></tr>
<tr class="separator:a5743b6b3fd75506c9ad40a0e840909d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870e71bbd742cc544d3f137712af7063"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a870e71bbd742cc544d3f137712af7063">cMsgToString</a> (const void *vmsg, char **string)</td></tr>
<tr class="separator:a870e71bbd742cc544d3f137712af7063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd12211e4b81a12bedfa8faa0fb862e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#acdd12211e4b81a12bedfa8faa0fb862e">cMsgToString2</a> (const void *vmsg, char **string, int binary, int compact, int noSystemFields)</td></tr>
<tr class="separator:acdd12211e4b81a12bedfa8faa0fb862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1194149886832c788ad3e5cec152423a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a1194149886832c788ad3e5cec152423a">cMsgPayloadToString</a> (const void *vmsg, char **string, int binary, int compact, int noSystemFields)</td></tr>
<tr class="separator:a1194149886832c788ad3e5cec152423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6360e84cffbe4fadb7effc698762d3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a0b6360e84cffbe4fadb7effc698762d3">escapeQuotesForXML</a> (char *s)</td></tr>
<tr class="separator:a0b6360e84cffbe4fadb7effc698762d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef61243c0b72221fbd38bd1d6de1c91"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a7ef61243c0b72221fbd38bd1d6de1c91">escapeCdataForXML</a> (char *s)</td></tr>
<tr class="separator:a7ef61243c0b72221fbd38bd1d6de1c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0144cc0cb39c6a8e1e0d63942a58d16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#af0144cc0cb39c6a8e1e0d63942a58d16">cMsgGetSubscriptionDomain</a> (const void *vmsg, const char **domain)</td></tr>
<tr class="separator:af0144cc0cb39c6a8e1e0d63942a58d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87027a186787990d1494be0efd9bc56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aa87027a186787990d1494be0efd9bc56">cMsgGetSubscriptionSubject</a> (const void *vmsg, const char **subject)</td></tr>
<tr class="separator:aa87027a186787990d1494be0efd9bc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe0764303285ec69cbe96b2dfb8a37e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#acfe0764303285ec69cbe96b2dfb8a37e">cMsgGetSubscriptionType</a> (const void *vmsg, const char **type)</td></tr>
<tr class="separator:acfe0764303285ec69cbe96b2dfb8a37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173893c0ea87d53f715dc5d467788b4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a173893c0ea87d53f715dc5d467788b4e">cMsgGetSubscriptionUDL</a> (const void *vmsg, const char **udl)</td></tr>
<tr class="separator:a173893c0ea87d53f715dc5d467788b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad011394994f936cf5e59af00f9522255"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ad011394994f936cf5e59af00f9522255">cMsgGetSubscriptionCueSize</a> (const void *vmsg, int *size)</td></tr>
<tr class="separator:ad011394994f936cf5e59af00f9522255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad249624d87a7577a8d6fa838278a68e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ad249624d87a7577a8d6fa838278a68e0">cMsgSetReliableSend</a> (void *vmsg, int boolean)</td></tr>
<tr class="separator:ad249624d87a7577a8d6fa838278a68e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90345420a9a31829151a88a35f3f5cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#af90345420a9a31829151a88a35f3f5cc">cMsgGetReliableSend</a> (void *vmsg, int *boolean)</td></tr>
<tr class="separator:af90345420a9a31829151a88a35f3f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d0b394963dec7f2c61111d0c0568e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#abc4d0b394963dec7f2c61111d0c0568e">cMsgSubscribeConfigCreate</a> (void)</td></tr>
<tr class="separator:abc4d0b394963dec7f2c61111d0c0568e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d045c6bbb85efe3e94227acc1153072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a9d045c6bbb85efe3e94227acc1153072">cMsgSubscribeConfigDestroy</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config)</td></tr>
<tr class="separator:a9d045c6bbb85efe3e94227acc1153072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47b52751025fdb3588d2947b085eb3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae47b52751025fdb3588d2947b085eb3e">cMsgSubscribeSetMaxCueSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int size)</td></tr>
<tr class="separator:ae47b52751025fdb3588d2947b085eb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1805ff17bd33dfb0a93049417d07bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a6a1805ff17bd33dfb0a93049417d07bb">cMsgSubscribeGetMaxCueSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *size)</td></tr>
<tr class="separator:a6a1805ff17bd33dfb0a93049417d07bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da5fb98446bf42337fdaf4a11414929"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a7da5fb98446bf42337fdaf4a11414929">cMsgSubscribeSetSkipSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int size)</td></tr>
<tr class="separator:a7da5fb98446bf42337fdaf4a11414929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12842dac9c2dadf7d7713a85b7b28f88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a12842dac9c2dadf7d7713a85b7b28f88">cMsgSubscribeGetSkipSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *size)</td></tr>
<tr class="separator:a12842dac9c2dadf7d7713a85b7b28f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529a2d3840fa660988641dc5b197cc44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a529a2d3840fa660988641dc5b197cc44">cMsgSubscribeSetMaySkip</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int maySkip)</td></tr>
<tr class="separator:a529a2d3840fa660988641dc5b197cc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bed7080ef38765b1d68ef8740aedb11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a2bed7080ef38765b1d68ef8740aedb11">cMsgSubscribeGetMaySkip</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *maySkip)</td></tr>
<tr class="separator:a2bed7080ef38765b1d68ef8740aedb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52cae1f0be6c43c9f491c6a7128db0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int serialize)</td></tr>
<tr class="separator:aea52cae1f0be6c43c9f491c6a7128db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9415e46ee1b516b010cf5eef28666c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a8b9415e46ee1b516b010cf5eef28666c">cMsgSubscribeGetMustSerialize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *serialize)</td></tr>
<tr class="separator:a8b9415e46ee1b516b010cf5eef28666c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69abb5bcff7d143799192fb12646de06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a69abb5bcff7d143799192fb12646de06">cMsgSubscribeSetMaxThreads</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int threads)</td></tr>
<tr class="separator:a69abb5bcff7d143799192fb12646de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc108298020f8e3c71ff33f7a96d3b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a7dc108298020f8e3c71ff33f7a96d3b2">cMsgSubscribeGetMaxThreads</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *threads)</td></tr>
<tr class="separator:a7dc108298020f8e3c71ff33f7a96d3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac01109573ba8542848272978e0c627c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#aac01109573ba8542848272978e0c627c">cMsgSubscribeSetMessagesPerThread</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int mpt)</td></tr>
<tr class="separator:aac01109573ba8542848272978e0c627c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e8922c48e59728cccf3d042b04f56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#afe1e8922c48e59728cccf3d042b04f56">cMsgSubscribeGetMessagesPerThread</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *mpt)</td></tr>
<tr class="separator:afe1e8922c48e59728cccf3d042b04f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d900c90f49e384fe2b8133f6db0a37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#af4d900c90f49e384fe2b8133f6db0a37">cMsgSubscribeSetStackSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, size_t size)</td></tr>
<tr class="separator:af4d900c90f49e384fe2b8133f6db0a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddeab46092de2ccb0e84eacab7046dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a0ddeab46092de2ccb0e84eacab7046dd">cMsgSubscribeGetStackSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, size_t *size)</td></tr>
<tr class="separator:a0ddeab46092de2ccb0e84eacab7046dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae3a5aa8533b31f04c9126398a7be17be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#ae3a5aa8533b31f04c9126398a7be17be">cMsgDebug</a> = <a class="el" href="../../de/d99/c_msg_constants_8h.html#a89a0e60afe8f3466ca2bf73301e72fcd">CMSG_DEBUG_ERROR</a></td></tr>
<tr class="separator:ae3a5aa8533b31f04c9126398a7be17be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1c5b9c5235ec909f19a8c89fe67869"><td class="memItemLeft" align="right" valign="top">domainTypeInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#acf1c5b9c5235ec909f19a8c89fe67869">cmsgDomainTypeInfo</a></td></tr>
<tr class="separator:acf1c5b9c5235ec909f19a8c89fe67869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d08b4fcd1b8dfd0ad0419ca5d0ec1f8"><td class="memItemLeft" align="right" valign="top">domainTypeInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a1d08b4fcd1b8dfd0ad0419ca5d0ec1f8">fileDomainTypeInfo</a></td></tr>
<tr class="separator:a1d08b4fcd1b8dfd0ad0419ca5d0ec1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8298b165ec34393845b48f5d2e8bc8"><td class="memItemLeft" align="right" valign="top">domainTypeInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a0d8298b165ec34393845b48f5d2e8bc8">rcDomainTypeInfo</a></td></tr>
<tr class="separator:a0d8298b165ec34393845b48f5d2e8bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078a51d8ff3e48baab7c7ab8045d96a1"><td class="memItemLeft" align="right" valign="top">domainTypeInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/c_msg_8c.html#a078a51d8ff3e48baab7c7ab8045d96a1">emuDomainTypeInfo</a></td></tr>
<tr class="separator:a078a51d8ff3e48baab7c7ab8045d96a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the entire cMsg user API.</p>
<p><b>Introduction</b></p>
<p>The user API acts as a multiplexor. Depending on the particular UDL used to connect to a specific cMsg server, the API will direct the user's library calls to the appropriate cMsg implementation. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a88ac8658ddc9211f67247f7e72c1950c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ac8658ddc9211f67247f7e72c1950c">&#9670;&nbsp;</a></span>LOCAL_ARRAY_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCAL_ARRAY_SIZE&#160;&#160;&#160;200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of local array elements in connectionPointers array. </p>

</div>
</div>
<a id="a58ce36916c399104e18d32ff090f21c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ce36916c399104e18d32ff090f21c6">&#9670;&nbsp;</a></span>MAX_STR_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_STR_LEN&#160;&#160;&#160;2000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5510f92d0e9c27ce594d9612eda88975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5510f92d0e9c27ce594d9612eda88975">&#9670;&nbsp;</a></span>parsedUDL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct parsedUDL_t <a class="el" href="../../d6/de2/c_msg_8c.html#a5510f92d0e9c27ce594d9612eda88975">parsedUDL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure contains the components of a given UDL broken down into its consituent parts. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acc8551bd36bdc8138c0c9574daa3d1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8551bd36bdc8138c0c9574daa3d1fc">&#9670;&nbsp;</a></span>cMsgConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgConnect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>myUDL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>myName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>myDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>domainId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine is called once to connect to a domain. The argument "myUDL" is the Universal Domain Locator used to uniquely identify the cMsg server to connect to. It has the form:</p>
<p><b><em>cMsg:domainType://domainInfo </em></b></p>
<p>The argument "myName" is the client's name and may be required to be unique within the domain depending on the domain. The argument "myDescription" is an arbitrary string used to describe the client. If successful, this routine fills the argument "domainId", which identifies the connection uniquely and is required as an argument by many other routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myUDL</td><td>the Universal Domain Locator used to uniquely identify the cMsg server to connect to </td></tr>
    <tr><td class="paramname">myName</td><td>name of this client </td></tr>
    <tr><td class="paramname">myDescription</td><td>description of this client </td></tr>
    <tr><td class="paramname">domainId</td><td>pointer to pointer which gets filled with a unique id referring to this connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if regular expression compilation fails during UDL parsing or circular UDL references </dd>
<dd>
CMSG_BAD_ARGUMENT if one of the arguments is bad </dd>
<dd>
CMSG_BAD_FORMAT if the UDL is formatted incorrectly </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory (allocated or static) </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgConnect </dd></dl>

</div>
</div>
<a id="a77bb3706d4c1cf31e44f1f9f1ccb78de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bb3706d4c1cf31e44f1f9f1ccb78de">&#9670;&nbsp;</a></span>cMsgCopyMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCopyMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine copies a message. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>. If the given message has a byte array that was copied in, it is copied again into the new message. Otherwise, if it has a byte array whose pointer was copied, the new message will point to the same byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message structure being copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the message copy </dd>
<dd>
NULL if argument is NULL or no memory available </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d6/de2/c_msg_8c.html#a2f976f80a20b3e5c2a64dd9da0a2648a">cMsgCreateNewMessage()</a>.</p>

</div>
</div>
<a id="a06e3ca9feea4b9cdd4f5d5bc144b57ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e3ca9feea4b9cdd4f5d5bc144b57ce">&#9670;&nbsp;</a></span>cMsgCreateMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCreateMessage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine creates a new, initialized message. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new message </dd>
<dd>
NULL if no memory available </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d6/de2/c_msg_8c.html#a5ce032c8bdf39718197d7d6d2f9914d0">cMsgCreateNullResponseMessage()</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a1e3f2a3e781de0f85bfb16c4cfb9dba3">cMsgCreateResponseMessage()</a>.</p>

</div>
</div>
<a id="a2f976f80a20b3e5c2a64dd9da0a2648a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f976f80a20b3e5c2a64dd9da0a2648a">&#9670;&nbsp;</a></span>cMsgCreateNewMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCreateNewMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine copies the given message, clears the history, and is marked as NOT having been sent. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message being copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new message </dd>
<dd>
NULL if no memory available or message argument is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../d6/de2/c_msg_8c.html#a77bb3706d4c1cf31e44f1f9f1ccb78de">cMsgCopyMessage()</a>.</p>

</div>
</div>
<a id="a5ce032c8bdf39718197d7d6d2f9914d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce032c8bdf39718197d7d6d2f9914d0">&#9670;&nbsp;</a></span>cMsgCreateNullResponseMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCreateNullResponseMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine creates a new, initialized message with some fields copied from the given message in order to make it a proper "NULL" (or no message) response to a sendAndGet() request. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message to which response fields are set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new message </dd>
<dd>
NULL if no memory available, message argument is NULL, or message argument is not from calling sendAndGet() </dd></dl>

<p class="reference">References <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>.</p>

</div>
</div>
<a id="a1e3f2a3e781de0f85bfb16c4cfb9dba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3f2a3e781de0f85bfb16c4cfb9dba3">&#9670;&nbsp;</a></span>cMsgCreateResponseMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCreateResponseMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine creates a new, initialized message with some fields copied from the given message in order to make it a proper response to a sendAndGet() request. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message to which response fields are set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new message </dd>
<dd>
NULL if no memory available, message argument is NULL, or message argument is not from calling sendAndGet() </dd></dl>

<p class="reference">References <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>.</p>

</div>
</div>
<a id="a86b9114fb29704d0e2d64c22e6287adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b9114fb29704d0e2d64c22e6287adc">&#9670;&nbsp;</a></span>cMsgDisconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgDisconnect </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine disconnects the client from the cMsg server. May only call this once if it succeeds since it frees memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>address of domain connection id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if this routine already called for the given domainId </dd>
<dd>
CMSG_BAD_ARGUMENT if the domainId or the pointer it refers to is NULL, or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
CMSG_LOST_CONNECTION if no longer connected to domain </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgDisconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="adab9134878cc0058e9ae3128a445ff00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab9134878cc0058e9ae3128a445ff00">&#9670;&nbsp;</a></span>cMsgFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgFlush </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends any pending (queued up) communication with the server. The implementation of this routine depends entirely on the domain in which it is being used. In the cMsg domain, this routine does nothing as all server communications are sent immediately upon calling any function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">timeout</td><td>amount of time to wait for completion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgFlush </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ad5f804fe6777fdc77fbd35fceac93bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f804fe6777fdc77fbd35fceac93bdb">&#9670;&nbsp;</a></span>cMsgFreeMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgFreeMessage </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine frees the memory allocated in the creation of a message. The cMsg client must call this routine on any messages created to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>address of pointer to message structure being freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if msg is NULL </dd></dl>

</div>
</div>
<a id="ad2ee42d5511e7fd79166c52d8d3658c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ee42d5511e7fd79166c52d8d3658c1">&#9670;&nbsp;</a></span>cMsgFreeMessage_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgFreeMessage_r </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine frees the memory allocated in the creation of a message, but in a way which avoids mutex deadlock when recursively freeing a payload's cMsgMessage items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>address of pointer to message structure being freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if msg is NULL </dd></dl>

</div>
</div>
<a id="ae3c3d89bdcb1c8dd313bff4127e84daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c3d89bdcb1c8dd313bff4127e84daa">&#9670;&nbsp;</a></span>cMsgGetByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArray </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets a message's byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">array</td><td>pointer to be filled with byte array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a118367970210f0d7b28f7c5cad6f9115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118367970210f0d7b28f7c5cad6f9115">&#9670;&nbsp;</a></span>cMsgGetByteArrayEndian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArrayEndian </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the endianness of the byte array data. Valid returned values are: </p><ul>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">endian</td><td>int pointer to be filled with byte array data endianness</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a086309234f06d80deccb0b8229d22a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086309234f06d80deccb0b8229d22a6b">&#9670;&nbsp;</a></span>cMsgGetByteArrayLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArrayLength </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the region-of-interest length of a message's byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">length</td><td>int pointer to be filled with byte array length (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aa2f394c8f794a935d32377cfa4827591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f394c8f794a935d32377cfa4827591">&#9670;&nbsp;</a></span>cMsgGetByteArrayLengthFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArrayLengthFull </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the total length of a message's byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">length</td><td>int pointer to be filled with byte array's total length (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a0c298192a9c6ac566e0a5094c98f68d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c298192a9c6ac566e0a5094c98f68d0">&#9670;&nbsp;</a></span>cMsgGetByteArrayOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArrayOffset </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the region-of-interest offset of a message's byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">offset</td><td>int pointer to be filled with byte array offset index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a7a307fac8a81b863c9fcb57e30b8c045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a307fac8a81b863c9fcb57e30b8c045">&#9670;&nbsp;</a></span>cMsgGetConnectState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetConnectState </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>connected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the state of a cMsg connection. If connectState gets filled with a one, there is a valid connection. Anything else (zero in this case), indicates client is not connected. The meaning of "connected" may vary with domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">connected</td><td>integer pointer to be filled in with connection state, (1-connected, 0-unconnected)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgGetConnectState </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="aff1b1b374341bb88557fc26b32c3054c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1b1b374341bb88557fc26b32c3054c">&#9670;&nbsp;</a></span>cMsgGetCurrentUDL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetCurrentUDL </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>udl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the UDL current used in the existing connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">udl</td><td>pointer filled in with current UDL or NULL if no connection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called or udl arg is NULL </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgGetConnectState </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a1820f554cad254ee20a559a409c47725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1820f554cad254ee20a559a409c47725">&#9670;&nbsp;</a></span>cMsgGetDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetDescription </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the client description used in a cMsg connection. If successful, this routine will return a pointer to char inside the system structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">description</td><td>pointer to pointer filled with the description</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_BAD_ARGUMENT if either arg is NULL </dd>
<dd>
CMSG_OK if successful </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a63ecf71837d95900cf511c9d0cd1f397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ecf71837d95900cf511c9d0cd1f397">&#9670;&nbsp;</a></span>cMsgGetDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetDomain </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the domain of a message. When a message is newly created (eg. by <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>), the domain field of a message is not set. In the cMsg domain, the cMsg server sets this field when it receives a client's sent message. Messages received from the server will have this field set. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">domain</td><td>pointer to pointer filled with message's cMsg domain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ae0e02fcce345ec42440fc3ebc4c8881e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e02fcce345ec42440fc3ebc4c8881e">&#9670;&nbsp;</a></span>cMsgGetGetRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetGetRequest </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>getRequest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the "get request" field of a message. The "get
request" field indicates the message was sent by a sendAndGet call, if it has a value of 1. A value of 0 indicates it was not sent by a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">getRequest</td><td>integer pointer to be filled in with 1 if message sent by a sendAndGet and 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="acdaa825de16af9f161cba410e0c91f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaa825de16af9f161cba410e0c91f74">&#9670;&nbsp;</a></span>cMsgGetGetResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetGetResponse </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>getResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the "get response" field of a message. The "get
reponse" field indicates the message is a response to a message sent by a sendAndGet call, if it has a value of 1. A value of 0 indicates it is not a response to a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">getResponse</td><td>integer pointer to be filled in 1 if message is a response to a sendAndGet and 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="adc1e33b4645d96f5746fc496b9dff35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1e33b4645d96f5746fc496b9dff35c">&#9670;&nbsp;</a></span>cMsgGetHistoryLengthMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetHistoryLengthMax </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the maximum number of entries this message keeps of its history of various parameters (sender's name, host, time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">len</td><td>integer pointer to be filled inwith max number of entries this message keeps of its history of various parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a57f251bf48c97c7822b5ca1a91bd620e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f251bf48c97c7822b5ca1a91bd620e">&#9670;&nbsp;</a></span>cMsgGetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInfo </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine does general I/O and returns a string for each string argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">command</td><td>command whose value determines what is returned in string arg </td></tr>
    <tr><td class="paramname">string</td><td>pointer which gets filled in with a return string (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED this routine is not implemented </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a7c9b5fe19b27451658aefbb62f0f138b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9b5fe19b27451658aefbb62f0f138b">&#9670;&nbsp;</a></span>cMsgGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetName </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the client name used in a cMsg connection. If successful, this routine will return a pointer to char inside the system structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">name</td><td>pointer to pointer filled with the name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_BAD_ARGUMENT if either arg is NULL </dd>
<dd>
CMSG_OK if successful </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a2b25010d5d27303d15288212e018a6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b25010d5d27303d15288212e018a6c2">&#9670;&nbsp;</a></span>cMsgGetNullGetResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetNullGetResponse </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nullGetResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the "NULL get response" field of a message. If it has a value of 1, the "NULL get response" field indicates that if the message is a response to a message sent by a sendAndGet call, when sent it will be received as a NULL pointer - not a message. Any other value indicates it is not a null get response to a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">nullGetResponse</td><td>integer pointer to be filled in with 1 if message is a NULL response to a sendAndGet and 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ae9c0eac1762db63b9e0507ea6204df47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c0eac1762db63b9e0507ea6204df47">&#9670;&nbsp;</a></span>cMsgGetPayloadText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetPayloadText </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>payloadText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the payload text of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">payloadText</td><td>pointer to pointer filled with message's payload text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ab74ea9c810a5e21db3fc7ee2a70c1fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74ea9c810a5e21db3fc7ee2a70c1fdd">&#9670;&nbsp;</a></span>cMsgGetReceiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReceiver </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>receiver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the receiver of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">receiver</td><td>pointer to pointer filled with message's receiver</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af610fc6f5b12d664021f9bbddd83737c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af610fc6f5b12d664021f9bbddd83737c">&#9670;&nbsp;</a></span>cMsgGetReceiverHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReceiverHost </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>receiverHost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the host of the receiver of a message. This field is NULL for a newly created message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">receiverHost</td><td>pointer to pointer filled with host of the message receiver</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a5743b6b3fd75506c9ad40a0e840909d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5743b6b3fd75506c9ad40a0e840909d2">&#9670;&nbsp;</a></span>cMsgGetReceiverTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReceiverTime </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>receiverTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the time a message was received (in seconds since midnight GMT, Jan 1st, 1970).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">receiverTime</td><td>pointer to be filled with time message was received</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a9945b6ed528879a54cbc0611373a8f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9945b6ed528879a54cbc0611373a8f71">&#9670;&nbsp;</a></span>cMsgGetReceiveState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReceiveState </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>receiveState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the message receiving state of a cMsg connection. If receiveState gets filled with a one, all messages sent to the client will be received and sent to appropriate callbacks . Anything else (zero in this case), indicates no messages will be received or sent to callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">receiveState</td><td>integer pointer to be filled in with the receive state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_BAD_ARGUMENT if either arg is NULL </dd>
<dd>
CMSG_OK if successful </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af90345420a9a31829151a88a35f3f5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90345420a9a31829151a88a35f3f5cc">&#9670;&nbsp;</a></span>cMsgGetReliableSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReliableSend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>boolean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets whether the send will be reliable (default, TCP) or will be allowed to be unreliable (UDP).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">boolean</td><td>int pointer to be filled with 1 if true (TCP), else 0 (UDP)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a0969391dfcd3cd8289eb04fc6399b602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0969391dfcd3cd8289eb04fc6399b602">&#9670;&nbsp;</a></span>cMsgGetSender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSender </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the sender of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">sender</td><td>pointer to pointer filled with message's sender</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aa65857ff0e87362d5098ca5e7c63961d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65857ff0e87362d5098ca5e7c63961d">&#9670;&nbsp;</a></span>cMsgGetSenderHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSenderHost </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>senderHost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the host of the sender of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">senderHost</td><td>pointer to pointer filled with host of the message sender</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ac2d3b1e0b664616cb77b6966e0dce97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d3b1e0b664616cb77b6966e0dce97e">&#9670;&nbsp;</a></span>cMsgGetSenderTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSenderTime </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>senderTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the time a message was last sent (in seconds since midnight GMT, Jan 1st, 1970).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">senderTime</td><td>pointer to be filled with time message was last sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="adb2487f6d2221f988e2b0dca1b3004cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2487f6d2221f988e2b0dca1b3004cd">&#9670;&nbsp;</a></span>cMsgGetServerHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetServerHost </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ipAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the IP address (in dotted-decimal form) that the client used to make the network connection to itsserver. Do NOT write into or free the returned char pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">ipAddress</td><td>pointer filled in with server IP address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED if not implemented in the given domain </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ae0fb1e1c06d2296e4c39e1ef388311c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fb1e1c06d2296e4c39e1ef388311c2">&#9670;&nbsp;</a></span>cMsgGetServerPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetServerPort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the port that the client used to make the network connection to its server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">port</td><td>pointer filled in with server TCP port</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED if not implemented in the given domain </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="aebd99fe965b1a18f041853f167e41d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd99fe965b1a18f041853f167e41d67">&#9670;&nbsp;</a></span>cMsgGetSubject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubject </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>subject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the subject of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">subject</td><td>pointer to pointer filled with message's subject</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ad011394994f936cf5e59af00f9522255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad011394994f936cf5e59af00f9522255">&#9670;&nbsp;</a></span>cMsgGetSubscriptionCueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionCueSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the cue size of a callback and is valid only when used in a callback on the message given in the callback argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">size</td><td>pointer which gets filled with a callback's cue size or -1 if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af0144cc0cb39c6a8e1e0d63942a58d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0144cc0cb39c6a8e1e0d63942a58d16">&#9670;&nbsp;</a></span>cMsgGetSubscriptionDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionDomain </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the domain a subscription is running in and is valid only when used in a callback on the message given in the callback argument. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">domain</td><td>pointer to pointer filled with a subscription's domain or NULL if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aa87027a186787990d1494be0efd9bc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87027a186787990d1494be0efd9bc56">&#9670;&nbsp;</a></span>cMsgGetSubscriptionSubject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionSubject </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>subject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the subject a subscription is using and is valid only when used in a callback on the message given in the callback argument. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">subject</td><td>pointer to pointer filled with a subscription's subject or NULL if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="acfe0764303285ec69cbe96b2dfb8a37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe0764303285ec69cbe96b2dfb8a37e">&#9670;&nbsp;</a></span>cMsgGetSubscriptionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the type a subscription is using and is valid only when used in a callback on the message given in the callback argument. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">type</td><td>pointer to pointer filled with a subscription's type or NULL if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a173893c0ea87d53f715dc5d467788b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173893c0ea87d53f715dc5d467788b4e">&#9670;&nbsp;</a></span>cMsgGetSubscriptionUDL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionUDL </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>udl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the udl of a subscription's connection and is valid only when used in a callback on the message given in the callback argument. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">udl</td><td>pointer to pointer filled with the udl of a subscription's connection or NULL if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a1e6b173d6ee98259bd9e2e3aeb9e1a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6b173d6ee98259bd9e2e3aeb9e1a34">&#9670;&nbsp;</a></span>cMsgGetText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetText </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the text of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">text</td><td>pointer to pointer filled with a message's text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ac5079c24edb7c920c07c6e24c1e4908f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5079c24edb7c920c07c6e24c1e4908f">&#9670;&nbsp;</a></span>cMsgGetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the type of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">type</td><td>pointer to pointer filled with message's type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a8900e00f1d6651aa96547b19e2fb0005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8900e00f1d6651aa96547b19e2fb0005">&#9670;&nbsp;</a></span>cMsgGetUDL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUDL </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>udl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the UDL used to establish a cMsg connection. If successful, this routine will return a pointer to char inside the system structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">udl</td><td>pointer to pointer filled with the UDL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_BAD_ARGUMENT if either arg is NULL </dd>
<dd>
CMSG_OK if successful </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a77a6252706b0202d3920b8a78d6629f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a6252706b0202d3920b8a78d6629f0">&#9670;&nbsp;</a></span>cMsgGetUserInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUserInt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>userInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets a message's user-defined integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">userInt</td><td>integer pointer to be filled with message's user-defined integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ae709e7079a007ee88ebc0b41a4da8a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae709e7079a007ee88ebc0b41a4da8a7b">&#9670;&nbsp;</a></span>cMsgGetUserTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUserTime </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>userTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets a message's user-defined time (in seconds since midnight GMT, Jan 1st, 1970).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">userTime</td><td>time_t pointer to be filled with message's user-defined time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ad7995e48e5e280e505e37b4b5b72402c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7995e48e5e280e505e37b4b5b72402c">&#9670;&nbsp;</a></span>cMsgGetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetVersion </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the cMsg major version number of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">version</td><td>integer pointer to be filled in with cMsg major version</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aae8ef09efaaacfb7c007a8aeead0d103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8ef09efaaacfb7c007a8aeead0d103">&#9670;&nbsp;</a></span>cMsgInitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgInitMessage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initializes a message. It frees all allocated memory, sets all strings to NULL, and sets all numeric values to their default state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message structure being initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if msg is NULL </dd></dl>

</div>
</div>
<a id="ad01d705dd17d13231b8128c9767311fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01d705dd17d13231b8128c9767311fa">&#9670;&nbsp;</a></span>cMsgMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgMonitor </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>replyMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is a synchronous call to receive a message containing monitoring data which describes the state of the cMsg domain the user is connected to. The time is data was sent can be obtained by calling cMsgGetSenderTime. The monitoring data in xml format can be obtained by calling cMsgGetText.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">command</td><td>string to monitor data collecting routine </td></tr>
    <tr><td class="paramname">replyMsg</td><td>message received from the domain containing monitor data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSendAndGet </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a7679f62347f3d049024cd767da4cbbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7679f62347f3d049024cd767da4cbbcb">&#9670;&nbsp;</a></span>cMsgNeedToSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgNeedToSwap </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method specifies whether the endian value of the byte array is the same value as the local host. If not, a 1 is returned indicating that the data needs to be swapped. If so, a 0 is returned indicating that no swap is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">swap</td><td>int pointer to be filled with 1 if byte array needs swapping, else 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if local endianness is unknown </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1597f0497d2b0a8b2cdbb90763bc81e6">CMSG_ERROR</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a1194149886832c788ad3e5cec152423a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1194149886832c788ad3e5cec152423a">&#9670;&nbsp;</a></span>cMsgPayloadToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadToString </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noSystemFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine converts the message payload to an XML string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">string</td><td>is pointer to char* that will hold the malloc'd string </td></tr>
    <tr><td class="paramname">binary</td><td>includes binary as ASCII if true, else binary is ignored </td></tr>
    <tr><td class="paramname">compact</td><td>if true (!=0), do not include attributes with null or default integer values </td></tr>
    <tr><td class="paramname">noSystemFields</td><td>if true (!=0), do not include system (metadata) payload fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if internal payload parsing error, or cannot get a payload item's type or count </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

</div>
</div>
<a id="a81590fa3f03c5ffdc3faed419dc3cdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81590fa3f03c5ffdc3faed419dc3cdb9">&#9670;&nbsp;</a></span>cMsgPerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cMsgPerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a string describing the given error condition. It can also print out that same string with printf if the debug level is set to CMSG_DEBUG_ERROR or CMSG_DEBUG_SEVERE by <a class="el" href="../../d6/de2/c_msg_8c.html#ae43c67e4ed6b1f7118344ac9d5321e07">cMsgSetDebugLevel()</a>. The returned string is a static char array. This means it is not thread-safe and will be overwritten on subsequent calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error string </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5d513b47d171cea248637c2bdc139187">CMSG_ABORT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba97992a10e4e87de315036eaf4bb1f417">CMSG_ALREADY_EXISTS</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba6c89f0163243ff7fd28fa67c720c8b7d">CMSG_ALREADY_INIT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba9a8611ce306f93b6b502552f2295dd91">CMSG_BAD_DOMAIN_ID</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba76fc8476f93d9077f8d8163080f67e00">CMSG_BAD_DOMAIN_TYPE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba14dc89eebb9d4dd7f21143a3bd317059">CMSG_BAD_FORMAT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba755629b2e69b7ea10ae88d6986b0987f">CMSG_BAD_MESSAGE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a89a0e60afe8f3466ca2bf73301e72fcd">CMSG_DEBUG_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba2dcef6215c2d469d4f933c20a25f7e9b">CMSG_DIFFERENT_VERSION</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1597f0497d2b0a8b2cdbb90763bc81e6">CMSG_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55badbc882b9a97ab0c75723031541b5a094">CMSG_ILLEGAL_MSGTYPE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba2f2118e2b0bd5cbecad3048eaab44d4d">CMSG_LIMIT_EXCEEDED</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba2ee3ad0143bd2735cf8b5a406716a056">CMSG_LOST_CONNECTION</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae40de1fa5548b83d19a547359fbe8e26">CMSG_NETWORK_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba30d0a946e182b5c1a41912cc854fb31a">CMSG_NO_CLASS_FOUND</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba96b807512052ba091f330d45f63496a1">CMSG_NOT_IMPLEMENTED</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55badb84f7dd84b1990c82b1ce76bf2eb330">CMSG_OUT_OF_MEMORY</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf9fe8371ec9e971ff16d0c8d0e552d52">CMSG_OUT_OF_RANGE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba11bd0dbd03b15e5882267b760bfc4a2c">CMSG_PEND_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba8f96b16dc2a63ad5cd377278ca5e3525">CMSG_SERVER_DIED</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bab90f05cdbd0c81b1e199b4e51e7bf6a3">CMSG_SOCKET_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba907e98122298904b115c92945098b173">CMSG_TIMEOUT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba2b83c4b52e9e825ea375cb0b5ce91721">CMSG_WRONG_DOMAIN_TYPE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4f983976b8a0df0f083421742ea561be">CMSG_WRONG_PASSWORD</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#ae3a5aa8533b31f04c9126398a7be17be">cMsgDebug</a>.</p>

</div>
</div>
<a id="aca2d833b870683ee4c130056f4d12673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2d833b870683ee4c130056f4d12673">&#9670;&nbsp;</a></span>cMsgReceiveStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgReceiveStart </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine enables the receiving of messages and delivery to callbacks. The receiving of messages is disabled by default and must be explicitly enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgReceiveStart </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a1e6e3eb577613c7329f7518e74d0b3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6e3eb577613c7329f7518e74d0b3f7">&#9670;&nbsp;</a></span>cMsgReceiveStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgReceiveStop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine disables the receiving of messages and delivery to callbacks. The receiving of messages is disabled by default. This routine only has an effect when <a class="el" href="../../d6/de2/c_msg_8c.html#aca2d833b870683ee4c130056f4d12673">cMsgReceiveStart()</a> was previously called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgReceiveStop </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a790114f9c2091b5c2ff12774e6790ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790114f9c2091b5c2ff12774e6790ec5">&#9670;&nbsp;</a></span>cMsgReconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgReconnect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine tries to reconnect to the server if a connection is broken. The domainId argument is created by first calling <a class="el" href="../../d6/de2/c_msg_8c.html#acc8551bd36bdc8138c0c9574daa3d1fc">cMsgConnect()</a> and establishing a connection to a cMsg server</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if domainId is bad or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgReconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ae75519fd0576e1cc7ef8ff9eb333b7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75519fd0576e1cc7ef8ff9eb333b7bd">&#9670;&nbsp;</a></span>cMsgResetByteArrayLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgResetByteArrayLength </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine resets the region-of-interest length of a message's byte array to its total length or zero if there is none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ac0e85fe096860040adfeed9a8fffe175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e85fe096860040adfeed9a8fffe175">&#9670;&nbsp;</a></span>cMsgSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends a msg to the specified domain server. It is completely asynchronous and never blocks. The domain may require <a class="el" href="../../d6/de2/c_msg_8c.html#adab9134878cc0058e9ae3128a445ff00">cMsgFlush()</a> to be called to force delivery. The domainId argument is created by calling <a class="el" href="../../d6/de2/c_msg_8c.html#acc8551bd36bdc8138c0c9574daa3d1fc">cMsgConnect()</a> and establishing a connection to a cMsg server. The message to be sent may be created by calling <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>, <a class="el" href="../../d6/de2/c_msg_8c.html#a2f976f80a20b3e5c2a64dd9da0a2648a">cMsgCreateNewMessage()</a>, or <a class="el" href="../../d6/de2/c_msg_8c.html#a77bb3706d4c1cf31e44f1f9f1ccb78de">cMsgCopyMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to a message structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSend </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ad7b774e764c900e8f742102923642950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b774e764c900e8f742102923642950">&#9670;&nbsp;</a></span>cMsgSendAndGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSendAndGet </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sendMsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>replyMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets one message from another cMsg client by sending out an initial message to that responder. It is a synchronous routine that fails when no reply is received with the given timeout. This function can be thought of as a peer-to-peer exchange of messages. One message is sent to all listeners. The first responder to the initial message will have its single response message sent back to the original sender. In the cMsg domain, if there are no subscribers to get the sent message, this routine returns CMSG_OK, but with a NULL message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">sendMsg</td><td>messages to send to all listeners </td></tr>
    <tr><td class="paramname">timeout</td><td>amount of time to wait for the response message </td></tr>
    <tr><td class="paramname">replyMsg</td><td>message received from the responder; may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSendAndGet </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ae7b3d5d8af3c3f81a74ad0e27d74ef8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b3d5d8af3c3f81a74ad0e27d74ef8f">&#9670;&nbsp;</a></span>cMsgSetByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArray </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a message's byte array by copying "length" number of bytes into a newly allocated array. The offset is reset to 0 while the length is set to the given value. Any pre-existing byte array memory is freed if it was copied into the given message. If the given array is null, the message's byte array is set to null and both offset &amp; length are set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">array</td><td>byte array </td></tr>
    <tr><td class="paramname">length</td><td>number of bytes in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL, or length &lt; 0 </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55badb84f7dd84b1990c82b1ce76bf2eb330">CMSG_OUT_OF_MEMORY</a>.</p>

</div>
</div>
<a id="a549e77f6cc3fd844ecec74185a5c5551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549e77f6cc3fd844ecec74185a5c5551">&#9670;&nbsp;</a></span>cMsgSetByteArrayEndian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArrayEndian </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the endianness of the byte array data. Valid values are: </p><ul>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#a7b3bb11309d92556aa9babb74911b59a">CMSG_ENDIAN_LOCAL</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#aaca852f1a3397a930e3e2ff113770051">CMSG_ENDIAN_NOTLOCAL</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#ad91bcfd44813a809bbf9ad6cf1dcad34">CMSG_ENDIAN_SWITCH</a> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">endian</td><td>byte array's endianness</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if local endianness is unknown </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL, or endian is not equal to either CMSG_ENDIAN_BIG, CMSG_ENDIAN_LITTLE, CMSG_ENDIAN_LOCAL, CMSG_ENDIAN_NOTLOCAL, or CMSG_ENDIAN_SWITCH </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a7b3bb11309d92556aa9babb74911b59a">CMSG_ENDIAN_LOCAL</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#aaca852f1a3397a930e3e2ff113770051">CMSG_ENDIAN_NOTLOCAL</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#ad91bcfd44813a809bbf9ad6cf1dcad34">CMSG_ENDIAN_SWITCH</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1597f0497d2b0a8b2cdbb90763bc81e6">CMSG_ERROR</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a6b957b96d5723aeaae1b63a4075069d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b957b96d5723aeaae1b63a4075069d4">&#9670;&nbsp;</a></span>cMsgSetByteArrayLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArrayLength </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the region-of-interest length of a message's byte array. This may be smaller than the full length of the array if the user is only interested in a portion of the array. If the byte array is null, all non-negative values are accepted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">length</td><td>byte array's length (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_OUT_OF_RANGE if offset + length is beyond array bounds </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL or length &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf9fe8371ec9e971ff16d0c8d0e552d52">CMSG_OUT_OF_RANGE</a>.</p>

</div>
</div>
<a id="af51659c0d03d14d540d426a96e661800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51659c0d03d14d540d426a96e661800">&#9670;&nbsp;</a></span>cMsgSetByteArrayNoCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArrayNoCopy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a message's byte array by copying the array arg pointer but <b>NOT</b> the data pointed to. The length arg sets the total length of the array in bytes. Any pre-existing byte array data is freed if it was copied into the given message. If the given array is null, the message's byte array is set to null and both offset &amp; length are set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">array</td><td>byte array </td></tr>
    <tr><td class="paramname">length</td><td>number of bytes in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL or length is &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a82750dc5dcbb0630db7b9827190b8833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82750dc5dcbb0630db7b9827190b8833">&#9670;&nbsp;</a></span>cMsgSetByteArrayOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArrayOffset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the region-of-interest offset of a message's byte array. This may be non-zero if the user is only interested in a portion of the array. If the byte array is null, all non-negative values are accepted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">offset</td><td>byte array's offset index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_OUT_OF_RANGE if offset + length is beyond array bounds </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL or offset &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf9fe8371ec9e971ff16d0c8d0e552d52">CMSG_OUT_OF_RANGE</a>.</p>

</div>
</div>
<a id="ae43c67e4ed6b1f7118344ac9d5321e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43c67e4ed6b1f7118344ac9d5321e07">&#9670;&nbsp;</a></span>cMsgSetDebugLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetDebugLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the level of debug output. The argument should be one of:</p>
<ul>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#a9d166359cbaaaaebc9479ca8a9c47db5">CMSG_DEBUG_NONE</a></li>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#a18c7461e1ad40e27d96fbe542f9c1ca2">CMSG_DEBUG_INFO</a></li>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#abd45547509b8dd1eec77a274fb472a94">CMSG_DEBUG_SEVERE</a></li>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#a89a0e60afe8f3466ca2bf73301e72fcd">CMSG_DEBUG_ERROR</a></li>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#a6414c8d4a886423bcf9fe63c577a2d5e">CMSG_DEBUG_WARN</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>debug level desired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if debug level is bad </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a89a0e60afe8f3466ca2bf73301e72fcd">CMSG_DEBUG_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a18c7461e1ad40e27d96fbe542f9c1ca2">CMSG_DEBUG_INFO</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a9d166359cbaaaaebc9479ca8a9c47db5">CMSG_DEBUG_NONE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#abd45547509b8dd1eec77a274fb472a94">CMSG_DEBUG_SEVERE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a6414c8d4a886423bcf9fe63c577a2d5e">CMSG_DEBUG_WARN</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#ae3a5aa8533b31f04c9126398a7be17be">cMsgDebug</a>.</p>

</div>
</div>
<a id="a6a2bb01b48637157ccfb8df116a45664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2bb01b48637157ccfb8df116a45664">&#9670;&nbsp;</a></span>cMsgSetGetResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetGetResponse </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>getResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the "get response" field of a message. The "get
reponse" field indicates the message is a response to a message sent by a sendAndGet call, if it has a value of 1. Any other value indicates it is not a response to a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">getResponse</td><td>set to 1 if message is a response to a sendAndGet, anything else otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message argument is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aca4d353630206fa691bdb413eafe5d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4d353630206fa691bdb413eafe5d35">&#9670;&nbsp;</a></span>cMsgSetHistoryLengthMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetHistoryLengthMax </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the maximum number of entries this message keeps of its history of various parameters (sender's name, host, time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">len</td><td>max number of entries this message keeps of its history of various parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message argument is NULL </dd>
<dd>
CMSG_OUT_OF_RANGE if len &lt; 0 or &gt; CMSG_HISTORY_LENGTH_ABS_MAX </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf9fe8371ec9e971ff16d0c8d0e552d52">CMSG_OUT_OF_RANGE</a>.</p>

</div>
</div>
<a id="a5083e7b37722212b9eb94ff6f13753b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5083e7b37722212b9eb94ff6f13753b3">&#9670;&nbsp;</a></span>cMsgSetNullGetResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetNullGetResponse </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nullGetResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the "null get response" field of a message. If it has a value of 1, the "null get response" field indicates that if the message is a response to a message sent by a sendAndGet call, when sent it will be received as a NULL pointer - not a message. Any other value indicates it is not a null get response to a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">nullGetResponse</td><td>set to 1 if message is a null get response to a sendAndGet, anything else otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message argument is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ad249624d87a7577a8d6fa838278a68e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad249624d87a7577a8d6fa838278a68e0">&#9670;&nbsp;</a></span>cMsgSetReliableSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetReliableSend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>boolean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets whether the send will be reliable (default, TCP) or will be allowed to be unreliable (UDP).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">boolean</td><td>0 if false (use UDP), anything else true (use TCP)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a4fe6ba7c854be09a2362f22eeb44e194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe6ba7c854be09a2362f22eeb44e194">&#9670;&nbsp;</a></span>cMsgSetShutdownHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetShutdownHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a13c894556c5124a6f408f1b5266b414d">cMsgShutdownHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the shutdown handler function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handler</td><td>shutdown handler function </td></tr>
    <tr><td class="paramname">userArg</td><td>argument to shutdown handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgDisconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a890729efc8b63d8af59e54f98298ac3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890729efc8b63d8af59e54f98298ac3c">&#9670;&nbsp;</a></span>cMsgSetSubject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetSubject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the subject of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">subject</td><td>message subject</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a263231aeceba900e26f4b09f7d88f00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263231aeceba900e26f4b09f7d88f00a">&#9670;&nbsp;</a></span>cMsgSetText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetText </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the text of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">text</td><td>message text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a2ed62a8b39b6992c56bf9cdbfb00f80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed62a8b39b6992c56bf9cdbfb00f80f">&#9670;&nbsp;</a></span>cMsgSetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetType </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the type of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">type</td><td>message type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="afbd14b7dbe6db6fa21f267f0d75ba78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd14b7dbe6db6fa21f267f0d75ba78b">&#9670;&nbsp;</a></span>cMsgSetUDL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetUDL </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>UDL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine resets the UDL (may be a semicolon separated list of single UDLs). If a reconnect is done, the new UDLs will be used in the connection(s).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">UDL</td><td>new UDL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if not successful reading file for configFile domain UDL </dd>
<dd>
CMSG_BAD_FORMAT if configFile domain file contains UDL of configFile domain or if one of the UDLs is not in the correct format </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called or UDL arg has illegal characters or is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd>
<dd>
CMSG_WRONG_DOMAIN_TYPE one of the domains is of the wrong type </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSetUDL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="afc4c719e852b925e02cc43dc0c0a8c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4c719e852b925e02cc43dc0c0a8c3e">&#9670;&nbsp;</a></span>cMsgSetUserInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetUserInt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>userInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a message's user-defined integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">userInt</td><td>message's user-defined integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aaa8bbb7c3868d0b1c53721ea2c48683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8bbb7c3868d0b1c53721ea2c48683a">&#9670;&nbsp;</a></span>cMsgSetUserTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetUserTime </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>userTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a message's user-defined time (in seconds since midnight GMT, Jan 1st, 1970).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">userTime</td><td>message's user-defined time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="abaa4d67ad8d8fade9360751b919e23be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa4d67ad8d8fade9360751b919e23be">&#9670;&nbsp;</a></span>cMsgShutdownClients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgShutdownClients </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to shutdown the given clients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">client</td><td>client(s) to be shutdown </td></tr>
    <tr><td class="paramname">flag</td><td>flag describing the mode of shutdown: 0 to not include self, CMSG_SHUTDOWN_INCLUDE_ME to include self in shutdown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED if the subdomain used does NOT implement shutdown </dd>
<dd>
CMSG_NETWORK_ERROR if error in communicating with the server </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called or flag argument improper value </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgDisconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#aa90393045b767904855c0ae31b793c96">CMSG_SHUTDOWN_INCLUDE_ME</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ab7417c11023fa420004ba20da9b710bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7417c11023fa420004ba20da9b710bc">&#9670;&nbsp;</a></span>cMsgShutdownServers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgShutdownServers </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to shutdown the given servers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">server</td><td>server(s) to be shutdown </td></tr>
    <tr><td class="paramname">flag</td><td>flag describing the mode of shutdown: 0 to not include self, CMSG_SHUTDOWN_INCLUDE_ME to include self in shutdown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED if the subdomain used does NOT implement shutdown </dd>
<dd>
CMSG_NETWORK_ERROR if error in communicating with the server </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called or flag argument improper value </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgDisconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#aa90393045b767904855c0ae31b793c96">CMSG_SHUTDOWN_INCLUDE_ME</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a5d422d9f2f693414868af48a16d13649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d422d9f2f693414868af48a16d13649">&#9670;&nbsp;</a></span>cMsgSubscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribe </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2a5df4825a5a9beee6877d4e3c96f491">cMsgCallbackFunc</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine subscribes to messages of the given subject and type. When a message is received, the given callback is passed the message pointer and the userArg pointer and then is executed. A configuration structure is given to determine the behavior of the callback. Only 1 subscription for a specific combination of subject, type, callback and userArg is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">subject</td><td>subject of messages subscribed to </td></tr>
    <tr><td class="paramname">type</td><td>type of messages subscribed to </td></tr>
    <tr><td class="paramname">callback</td><td>pointer to callback to be executed on receipt of message </td></tr>
    <tr><td class="paramname">userArg</td><td>user-specified pointer to be passed to the callback </td></tr>
    <tr><td class="paramname">config</td><td>pointer to callback configuration structure </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to handle (void pointer) to be used for unsubscribing from this subscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscribe </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a7a497a089d800a0fb05a27d3e736e8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a497a089d800a0fb05a27d3e736e8c1">&#9670;&nbsp;</a></span>cMsgSubscribeAndGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeAndGet </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>replyMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets one message from a one-time subscription to the given subject and type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">subject</td><td>subject of message subscribed to </td></tr>
    <tr><td class="paramname">type</td><td>type of message subscribed to </td></tr>
    <tr><td class="paramname">timeout</td><td>amount of time to wait for the message </td></tr>
    <tr><td class="paramname">replyMsg</td><td>message received</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSendAndGet </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="abc4d0b394963dec7f2c61111d0c0568e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d0b394963dec7f2c61111d0c0568e">&#9670;&nbsp;</a></span>cMsgSubscribeConfigCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a>* cMsgSubscribeConfigCreate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine creates a structure of configuration information used to determine the behavior of a <a class="el" href="../../d6/de2/c_msg_8c.html#a5d422d9f2f693414868af48a16d13649">cMsgSubscribe()</a>'s callback. The configuration is filled with default values. Each aspect of the configuration may be modified by setter and getter functions. The defaults are:</p><ul>
<li>maximum messages to cue for callback is 10000</li>
<li>no messages may be skipped</li>
<li>calls to the callback function must be serialized</li>
<li>may skip up to 2000 messages at once if skipping is enabled</li>
<li>maximum number of threads when parallelizing calls to the callback function is 100</li>
<li>enough worker threads are started so that there are at most 150 unprocessed messages for each thread</li>
</ul>
<p>Note that this routine allocates memory and <a class="el" href="../../d6/de2/c_msg_8c.html#a9d045c6bbb85efe3e94227acc1153072">cMsgSubscribeConfigDestroy()</a> must be called to free it.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if no memory available </dd>
<dd>
pointer to configuration if successful </dd></dl>

</div>
</div>
<a id="a9d045c6bbb85efe3e94227acc1153072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d045c6bbb85efe3e94227acc1153072">&#9670;&nbsp;</a></span>cMsgSubscribeConfigDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeConfigDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine frees the memory associated with a configuration created by <a class="el" href="../../d6/de2/c_msg_8c.html#abc4d0b394963dec7f2c61111d0c0568e">cMsgSubscribeConfigCreate()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a6a1805ff17bd33dfb0a93049417d07bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1805ff17bd33dfb0a93049417d07bb">&#9670;&nbsp;</a></span>cMsgSubscribeGetMaxCueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMaxCueSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets a subscribe configuration's maximum message cue size. Messages are kept in the cue until they can be processed by the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>integer pointer to be filled with configuration's maximum cue size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a7dc108298020f8e3c71ff33f7a96d3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc108298020f8e3c71ff33f7a96d3b2">&#9670;&nbsp;</a></span>cMsgSubscribeGetMaxThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMaxThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the maximum number of threads a parallelized subscribe's callback can run at once. This setting is only used if <a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize()</a> was called with an argument of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">threads</td><td>integer pointer to be filled with the maximum number of threads a parallelized subscribe's callback can run at once</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a2bed7080ef38765b1d68ef8740aedb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bed7080ef38765b1d68ef8740aedb11">&#9670;&nbsp;</a></span>cMsgSubscribeGetMaySkip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMaySkip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maySkip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets whether messages may be skipped over (deleted) if too many messages are piling up in the cue. The maximum number of messages skipped at once is determined by <a class="el" href="../../d6/de2/c_msg_8c.html#a7da5fb98446bf42337fdaf4a11414929">cMsgSubscribeSetSkipSize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">maySkip</td><td>integer pointer to be filled with 0 if messages may NOT be skipped (deleted), or anything else otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="afe1e8922c48e59728cccf3d042b04f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1e8922c48e59728cccf3d042b04f56">&#9670;&nbsp;</a></span>cMsgSubscribeGetMessagesPerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMessagesPerThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>mpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the maximum number of unprocessed messages per thread before a new thread is started, if a callback is parallelized (<a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize()</a> set to 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">mpt</td><td>integer pointer to be filled with the maximum number of unprocessed messages per thread before starting another thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a8b9415e46ee1b516b010cf5eef28666c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9415e46ee1b516b010cf5eef28666c">&#9670;&nbsp;</a></span>cMsgSubscribeGetMustSerialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMustSerialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>serialize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets whether a subscribe's callback must be run serially (in one thread), or may be parallelized (run simultaneously in more than one thread) if more than 1 message is waiting in the cue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">serialize</td><td>integer pointer to be filled with 0 if callback may be parallelized, or anything else if callback must be serialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a12842dac9c2dadf7d7713a85b7b28f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12842dac9c2dadf7d7713a85b7b28f88">&#9670;&nbsp;</a></span>cMsgSubscribeGetSkipSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetSkipSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the number of messages to skip over (delete) if too many messages are piling up in the cue. Messages are only skipped if <a class="el" href="../../d6/de2/c_msg_8c.html#a529a2d3840fa660988641dc5b197cc44">cMsgSubscribeSetMaySkip()</a> sets the configuration to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>integer pointer to be filled with the number of messages to skip (delete)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a0ddeab46092de2ccb0e84eacab7046dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddeab46092de2ccb0e84eacab7046dd">&#9670;&nbsp;</a></span>cMsgSubscribeGetStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetStackSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the stack size in bytes of the subscription thread. By default the stack size is unspecified (returns 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>pointer to be filled with stack size in bytes of subscription thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ae47b52751025fdb3588d2947b085eb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47b52751025fdb3588d2947b085eb3e">&#9670;&nbsp;</a></span>cMsgSubscribeSetMaxCueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMaxCueSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a subscribe configuration's maximum message cue size. Messages are kept in the cue until they can be processed by the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>maximum cue size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or size &lt; 1 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a69abb5bcff7d143799192fb12646de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69abb5bcff7d143799192fb12646de06">&#9670;&nbsp;</a></span>cMsgSubscribeSetMaxThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMaxThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the maximum number of threads a parallelized subscribe's callback can run at once. This setting is only used if <a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize()</a> was called with an argument of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">threads</td><td>the maximum number of threads a parallelized subscribe's callback can run at once</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or threads &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a529a2d3840fa660988641dc5b197cc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529a2d3840fa660988641dc5b197cc44">&#9670;&nbsp;</a></span>cMsgSubscribeSetMaySkip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMaySkip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maySkip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets whether messages may be skipped over (deleted) if too many messages are piling up in the cue. The maximum number of messages skipped at once is determined by <a class="el" href="../../d6/de2/c_msg_8c.html#a7da5fb98446bf42337fdaf4a11414929">cMsgSubscribeSetSkipSize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">maySkip</td><td>set to 0 if messages may NOT be skipped, set to anything else otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aac01109573ba8542848272978e0c627c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac01109573ba8542848272978e0c627c">&#9670;&nbsp;</a></span>cMsgSubscribeSetMessagesPerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMessagesPerThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the maximum number of unprocessed messages per thread before a new thread is started, if a callback is parallelized (<a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize()</a> set to 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">mpt</td><td>set to maximum number of unprocessed messages per thread before starting another thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or mpt &lt; 1 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aea52cae1f0be6c43c9f491c6a7128db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea52cae1f0be6c43c9f491c6a7128db0">&#9670;&nbsp;</a></span>cMsgSubscribeSetMustSerialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMustSerialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>serialize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets whether a subscribe's callback must be run serially (in one thread), or may be parallelized (run simultaneously in more than one thread) if more than 1 message is waiting in the cue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">serialize</td><td>set to 0 if callback may be parallelized, or set to anything else if callback must be serialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a7da5fb98446bf42337fdaf4a11414929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da5fb98446bf42337fdaf4a11414929">&#9670;&nbsp;</a></span>cMsgSubscribeSetSkipSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetSkipSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the number of messages to skip over (delete) if too many messages are piling up in the cue. Messages are only skipped if <a class="el" href="../../d6/de2/c_msg_8c.html#a529a2d3840fa660988641dc5b197cc44">cMsgSubscribeSetMaySkip()</a> sets the configuration to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>number of messages to skip (delete)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or size &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af4d900c90f49e384fe2b8133f6db0a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d900c90f49e384fe2b8133f6db0a37">&#9670;&nbsp;</a></span>cMsgSubscribeSetStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetStackSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the stack size in bytes of the subscription thread. By default the stack size is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>stack size in bytes of subscription thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or size &lt; 1 byte </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a249f6269c777aacf10732643d1d3ecc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249f6269c777aacf10732643d1d3ecc7">&#9670;&nbsp;</a></span>cMsgSubscriptionMessagesTotal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionMessagesTotal </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the total number of messages sent to a subscription callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe </td></tr>
    <tr><td class="paramname">total</td><td>int pointer filled in with total number of messages sent to a subscription callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a267a55c66e6d13123ffc0dbcd6b541d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267a55c66e6d13123ffc0dbcd6b541d4">&#9670;&nbsp;</a></span>cMsgSubscriptionPause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionPause </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine pauses the delivery of messages to the given subscription callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
CMSG_NOT_IMPLEMENTED if the subdomain used does NOT implement this function </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ab20b7dedc9fe1cea771b46d6ac33c237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20b7dedc9fe1cea771b46d6ac33c237">&#9670;&nbsp;</a></span>cMsgSubscriptionQueueClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionQueueClear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine clears a subscription callback's queue of all messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if the id/handle is bad or handle is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a536677299fa10fc48bbcda4870ca441c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536677299fa10fc48bbcda4870ca441c">&#9670;&nbsp;</a></span>cMsgSubscriptionQueueCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionQueueCount </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the number of messages currently in a subscription callback's queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe </td></tr>
    <tr><td class="paramname">count</td><td>int pointer filled in with number of messages in subscription callback queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a78c6442b2ebbc21f2e03e46722117c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c6442b2ebbc21f2e03e46722117c5f">&#9670;&nbsp;</a></span>cMsgSubscriptionQueueIsFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionQueueIsFull </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns true(1) if a subscription callback's queue is full, else false(0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe </td></tr>
    <tr><td class="paramname">full</td><td>int pointer filled in with 1 if subscription callback queue full, else 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a07ee2459ff5f317674b7ea9e8df34d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ee2459ff5f317674b7ea9e8df34d0a">&#9670;&nbsp;</a></span>cMsgSubscriptionResume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionResume </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine resumes the delivery of messages to the given subscription callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
CMSG_NOT_IMPLEMENTED if the subdomain used does NOT implement this function </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a3e6d501ff5422314b650bd8c55f6f800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6d501ff5422314b650bd8c55f6f800">&#9670;&nbsp;</a></span>cMsgSyncSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSyncSend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends a msg to the specified domain server and receives a response. It is a synchronous routine and as a result blocks until it receives a status integer from the cMsg server. The domainId argument is created by calling <a class="el" href="../../d6/de2/c_msg_8c.html#acc8551bd36bdc8138c0c9574daa3d1fc">cMsgConnect()</a> and establishing a connection to a cMsg server. The message to be sent may be created by calling <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>, <a class="el" href="../../d6/de2/c_msg_8c.html#a2f976f80a20b3e5c2a64dd9da0a2648a">cMsgCreateNewMessage()</a>, or <a class="el" href="../../d6/de2/c_msg_8c.html#a77bb3706d4c1cf31e44f1f9f1ccb78de">cMsgCopyMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to a message structure </td></tr>
    <tr><td class="paramname">timeout</td><td>amount of time to wait for the response </td></tr>
    <tr><td class="paramname">response</td><td>integer pointer that gets filled with the response</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSyncSend </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a870e71bbd742cc544d3f137712af7063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870e71bbd742cc544d3f137712af7063">&#9670;&nbsp;</a></span>cMsgToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgToString </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine converts the message to an XML string. Everything is displayed including binary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">string</td><td>is pointer to char* that will hold the malloc'd string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if internal payload parsing error, or cannot get a payload item's type or count </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

</div>
</div>
<a id="acdd12211e4b81a12bedfa8faa0fb862e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd12211e4b81a12bedfa8faa0fb862e">&#9670;&nbsp;</a></span>cMsgToString2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgToString2 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noSystemFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine converts the message to an XML string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">string</td><td>is pointer to char* that will hold the malloc'd string </td></tr>
    <tr><td class="paramname">binary</td><td>includes binary as ASCII if true, else binary is ignored </td></tr>
    <tr><td class="paramname">compact</td><td>if true (!=0), do not include attributes with null or default integer values </td></tr>
    <tr><td class="paramname">noSystemFields</td><td>if true (!=0), do not include system (metadata) payload fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if internal payload parsing error, or cannot get a payload item's type or count </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

</div>
</div>
<a id="a04b867224188eca1aa6f9c61ba868adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b867224188eca1aa6f9c61ba868adb">&#9670;&nbsp;</a></span>cMsgTrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgTrim </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routine to trim white space from front and back of given string. Changes made to argument string in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be trimmed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1726f9ebefe2199ac38a60e35e0e1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1726f9ebefe2199ac38a60e35e0e1c7">&#9670;&nbsp;</a></span>cMsgTrimChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgTrimChar </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trimChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routine to trim a given character from front and back of given string. Changes made to argument string in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be trimmed </td></tr>
    <tr><td class="paramname">trimChar</td><td>character to be trimmed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0620f042ef32f864ed34dd47b9531ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0620f042ef32f864ed34dd47b9531ea7">&#9670;&nbsp;</a></span>cMsgTrimDoubleChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgTrimDoubleChars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trimChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routine to eliminate contiguous occurrences of a given character in given string. Changes made to argument string in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be trimmed </td></tr>
    <tr><td class="paramname">trimChar</td><td>character to be trimmed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1dab146eac57f2bd20f79628336c28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dab146eac57f2bd20f79628336c28b">&#9670;&nbsp;</a></span>cMsgUnSubscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgUnSubscribe </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine unsubscribes to messages of the given handle (which represents a given subject, type, callback, and user argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgUnSubscribe </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a375ef62e93bf9feb7195abd9257d11bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375ef62e93bf9feb7195abd9257d11bb">&#9670;&nbsp;</a></span>cMsgWasSent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgWasSent </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>hasBeenSent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns whether a message has been sent over the wire or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">hasBeenSent</td><td>pointer which gets filled with 1 if msg has been sent, else 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a7ef61243c0b72221fbd38bd1d6de1c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef61243c0b72221fbd38bd1d6de1c91">&#9670;&nbsp;</a></span>escapeCdataForXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* escapeCdataForXML </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine escapes CDATA constructs which will appear inside of XML CDATA sections. It is not possible to have nested cdata sections. Actually the CDATA ending sequence, ]]&gt; , is what cannot be containing in a surrounding CDATA section. This restriction can be cleverly circumvented by inserting "&amp;lt;![CDATA[]]]]&amp;gt;&amp;lt;![CDATA[&amp;gt;" after each CDATA ending sequence. This creates independent CDATA sections which are not nested.</p>
<p>This routine assumes that there are no nested cdata sections in the input string. Nothing is done to the string if: </p><ul>
<li>
there is no ]]&gt; so no escaping is necessary </li>
<li>
there is no &lt;![CDATA[ so s contains malformed XML </li>
<li>
a particular &lt;![CDATA[ has no corresponding ]]&gt; so s contains malformed XML </li>
<li>
]]&gt; comes before &lt;![CDATA[ so s contains malformed XML </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be escaped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>escaped string, NULL if no memory or arg is NULL </dd></dl>

</div>
</div>
<a id="a0b6360e84cffbe4fadb7effc698762d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6360e84cffbe4fadb7effc698762d3">&#9670;&nbsp;</a></span>escapeQuotesForXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* escapeQuotesForXML </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine escapes the " char for putting strings into XML. If no quotes are found, the original string is returned (no memory is allocated). If quotes are found, a new string is returned which must be freed by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be escaped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>escaped string, NULL if no memory or arg is NULL </dd></dl>

</div>
</div>
<a id="a0d77690be8974fa96f871258b78ea538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d77690be8974fa96f871258b78ea538">&#9670;&nbsp;</a></span>strndup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* strndup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae3a5aa8533b31f04c9126398a7be17be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a5aa8533b31f04c9126398a7be17be">&#9670;&nbsp;</a></span>cMsgDebug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgDebug = <a class="el" href="../../de/d99/c_msg_constants_8h.html#a89a0e60afe8f3466ca2bf73301e72fcd">CMSG_DEBUG_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global debug level. </p>

<p class="reference">Referenced by <a class="el" href="../../d6/de2/c_msg_8c.html#a81590fa3f03c5ffdc3faed419dc3cdb9">cMsgPerror()</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#ae43c67e4ed6b1f7118344ac9d5321e07">cMsgSetDebugLevel()</a>.</p>

</div>
</div>
<a id="acf1c5b9c5235ec909f19a8c89fe67869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1c5b9c5235ec909f19a8c89fe67869">&#9670;&nbsp;</a></span>cmsgDomainTypeInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">domainTypeInfo cmsgDomainTypeInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For domain implementations. </p>

</div>
</div>
<a id="a078a51d8ff3e48baab7c7ab8045d96a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078a51d8ff3e48baab7c7ab8045d96a1">&#9670;&nbsp;</a></span>emuDomainTypeInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">domainTypeInfo emuDomainTypeInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d08b4fcd1b8dfd0ad0419ca5d0ec1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d08b4fcd1b8dfd0ad0419ca5d0ec1f8">&#9670;&nbsp;</a></span>fileDomainTypeInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">domainTypeInfo fileDomainTypeInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d8298b165ec34393845b48f5d2e8bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8298b165ec34393845b48f5d2e8bc8">&#9670;&nbsp;</a></span>rcDomainTypeInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">domainTypeInfo rcDomainTypeInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_5809eee9415059aec03c0088f91a79db.html">libsrc</a></li><li class="navelem"><a class="el" href="../../d6/de2/c_msg_8c.html">cMsg.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
