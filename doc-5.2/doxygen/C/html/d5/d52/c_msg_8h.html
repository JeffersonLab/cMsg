<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cMsg Messaging System: cMsg.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cMsg Messaging System
   &#160;<span id="projectnumber">5.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d5/d52/c_msg_8h.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cMsg.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &quot;<a class="el" href="../../de/d99/c_msg_constants_8h_source.html">cMsgConstants.h</a>&quot;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
</div>
<p><a href="../../d5/d52/c_msg_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2df480a6bce32c360ad07d5e35e3b5c9"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a></td></tr>
<tr class="separator:a2df480a6bce32c360ad07d5e35e3b5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c894556c5124a6f408f1b5266b414d"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a13c894556c5124a6f408f1b5266b414d">cMsgShutdownHandler</a>(void *userArg)</td></tr>
<tr class="separator:a13c894556c5124a6f408f1b5266b414d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5df4825a5a9beee6877d4e3c96f491"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a2a5df4825a5a9beee6877d4e3c96f491">cMsgCallbackFunc</a>(void *msg, void *userArg)</td></tr>
<tr class="separator:a2a5df4825a5a9beee6877d4e3c96f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc8551bd36bdc8138c0c9574daa3d1fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#acc8551bd36bdc8138c0c9574daa3d1fc">cMsgConnect</a> (const char *myUDL, const char *myName, const char *myDescription, void **domainId)</td></tr>
<tr class="separator:acc8551bd36bdc8138c0c9574daa3d1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790114f9c2091b5c2ff12774e6790ec5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a790114f9c2091b5c2ff12774e6790ec5">cMsgReconnect</a> (void *domainId)</td></tr>
<tr class="separator:a790114f9c2091b5c2ff12774e6790ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e85fe096860040adfeed9a8fffe175"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac0e85fe096860040adfeed9a8fffe175">cMsgSend</a> (void *domainId, void *msg)</td></tr>
<tr class="separator:ac0e85fe096860040adfeed9a8fffe175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6d501ff5422314b650bd8c55f6f800"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a3e6d501ff5422314b650bd8c55f6f800">cMsgSyncSend</a> (void *domainId, void *msg, const struct timespec *timeout, int *response)</td></tr>
<tr class="separator:a3e6d501ff5422314b650bd8c55f6f800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab9134878cc0058e9ae3128a445ff00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#adab9134878cc0058e9ae3128a445ff00">cMsgFlush</a> (void *domainId, const struct timespec *timeout)</td></tr>
<tr class="separator:adab9134878cc0058e9ae3128a445ff00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d422d9f2f693414868af48a16d13649"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a5d422d9f2f693414868af48a16d13649">cMsgSubscribe</a> (void *domainId, const char *subject, const char *type, <a class="el" href="../../d5/d52/c_msg_8h.html#a2a5df4825a5a9beee6877d4e3c96f491">cMsgCallbackFunc</a> *callback, void *userArg, <a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, void **handle)</td></tr>
<tr class="separator:a5d422d9f2f693414868af48a16d13649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dab146eac57f2bd20f79628336c28b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac1dab146eac57f2bd20f79628336c28b">cMsgUnSubscribe</a> (void *domainId, void *handle)</td></tr>
<tr class="separator:ac1dab146eac57f2bd20f79628336c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267a55c66e6d13123ffc0dbcd6b541d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a267a55c66e6d13123ffc0dbcd6b541d4">cMsgSubscriptionPause</a> (void *domainId, void *handle)</td></tr>
<tr class="separator:a267a55c66e6d13123ffc0dbcd6b541d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ee2459ff5f317674b7ea9e8df34d0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a07ee2459ff5f317674b7ea9e8df34d0a">cMsgSubscriptionResume</a> (void *domainId, void *handle)</td></tr>
<tr class="separator:a07ee2459ff5f317674b7ea9e8df34d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20b7dedc9fe1cea771b46d6ac33c237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab20b7dedc9fe1cea771b46d6ac33c237">cMsgSubscriptionQueueClear</a> (void *domainId, void *handle)</td></tr>
<tr class="separator:ab20b7dedc9fe1cea771b46d6ac33c237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536677299fa10fc48bbcda4870ca441c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a536677299fa10fc48bbcda4870ca441c">cMsgSubscriptionQueueCount</a> (void *domainId, void *handle, int *count)</td></tr>
<tr class="separator:a536677299fa10fc48bbcda4870ca441c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6442b2ebbc21f2e03e46722117c5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a78c6442b2ebbc21f2e03e46722117c5f">cMsgSubscriptionQueueIsFull</a> (void *domainId, void *handle, int *full)</td></tr>
<tr class="separator:a78c6442b2ebbc21f2e03e46722117c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249f6269c777aacf10732643d1d3ecc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a249f6269c777aacf10732643d1d3ecc7">cMsgSubscriptionMessagesTotal</a> (void *domainId, void *handle, int *total)</td></tr>
<tr class="separator:a249f6269c777aacf10732643d1d3ecc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b774e764c900e8f742102923642950"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ad7b774e764c900e8f742102923642950">cMsgSendAndGet</a> (void *domainId, void *sendMsg, const struct timespec *timeout, void **replyMsg)</td></tr>
<tr class="separator:ad7b774e764c900e8f742102923642950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a497a089d800a0fb05a27d3e736e8c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a7a497a089d800a0fb05a27d3e736e8c1">cMsgSubscribeAndGet</a> (void *domainId, const char *subject, const char *type, const struct timespec *timeout, void **replyMsg)</td></tr>
<tr class="separator:a7a497a089d800a0fb05a27d3e736e8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01d705dd17d13231b8128c9767311fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ad01d705dd17d13231b8128c9767311fa">cMsgMonitor</a> (void *domainId, const char *command, void **replyMsg)</td></tr>
<tr class="separator:ad01d705dd17d13231b8128c9767311fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2d833b870683ee4c130056f4d12673"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aca2d833b870683ee4c130056f4d12673">cMsgReceiveStart</a> (void *domainId)</td></tr>
<tr class="separator:aca2d833b870683ee4c130056f4d12673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6e3eb577613c7329f7518e74d0b3f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1e6e3eb577613c7329f7518e74d0b3f7">cMsgReceiveStop</a> (void *domainId)</td></tr>
<tr class="separator:a1e6e3eb577613c7329f7518e74d0b3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b9114fb29704d0e2d64c22e6287adc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect</a> (void **domainId)</td></tr>
<tr class="separator:a86b9114fb29704d0e2d64c22e6287adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe6ba7c854be09a2362f22eeb44e194"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a4fe6ba7c854be09a2362f22eeb44e194">cMsgSetShutdownHandler</a> (void *domainId, <a class="el" href="../../d5/d52/c_msg_8h.html#a13c894556c5124a6f408f1b5266b414d">cMsgShutdownHandler</a> *handler, void *userArg)</td></tr>
<tr class="separator:a4fe6ba7c854be09a2362f22eeb44e194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa4d67ad8d8fade9360751b919e23be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#abaa4d67ad8d8fade9360751b919e23be">cMsgShutdownClients</a> (void *domainId, const char *client, int flag)</td></tr>
<tr class="separator:abaa4d67ad8d8fade9360751b919e23be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7417c11023fa420004ba20da9b710bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab7417c11023fa420004ba20da9b710bc">cMsgShutdownServers</a> (void *domainId, const char *server, int flag)</td></tr>
<tr class="separator:ab7417c11023fa420004ba20da9b710bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00bd9ec9c007d39521250f33fd767a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#af00bd9ec9c007d39521250f33fd767a5">cMsgGetConnectState</a> (void *domainId, int *connectState)</td></tr>
<tr class="separator:af00bd9ec9c007d39521250f33fd767a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd159c1ce8fa48fc9a4d3c4212827324"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#acd159c1ce8fa48fc9a4d3c4212827324">cMsgSetUDL</a> (void *domainId, const char *udl)</td></tr>
<tr class="separator:acd159c1ce8fa48fc9a4d3c4212827324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1b1b374341bb88557fc26b32c3054c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aff1b1b374341bb88557fc26b32c3054c">cMsgGetCurrentUDL</a> (void *domainId, const char **udl)</td></tr>
<tr class="separator:aff1b1b374341bb88557fc26b32c3054c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2487f6d2221f988e2b0dca1b3004cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#adb2487f6d2221f988e2b0dca1b3004cd">cMsgGetServerHost</a> (void *domainId, const char **ipAddress)</td></tr>
<tr class="separator:adb2487f6d2221f988e2b0dca1b3004cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fb1e1c06d2296e4c39e1ef388311c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae0fb1e1c06d2296e4c39e1ef388311c2">cMsgGetServerPort</a> (void *domainId, int *port)</td></tr>
<tr class="separator:ae0fb1e1c06d2296e4c39e1ef388311c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f251bf48c97c7822b5ca1a91bd620e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a57f251bf48c97c7822b5ca1a91bd620e">cMsgGetInfo</a> (void *domainId, const char *command, char **string)</td></tr>
<tr class="separator:a57f251bf48c97c7822b5ca1a91bd620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d58e5c65d27d6e17ce11988bbed9ce6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1d58e5c65d27d6e17ce11988bbed9ce6">cMsgPerror</a> (int errorCode)</td></tr>
<tr class="separator:a1d58e5c65d27d6e17ce11988bbed9ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f804fe6777fdc77fbd35fceac93bdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage</a> (void **vmsg)</td></tr>
<tr class="separator:ad5f804fe6777fdc77fbd35fceac93bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e3ca9feea4b9cdd4f5d5bc144b57ce"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage</a> (void)</td></tr>
<tr class="separator:a06e3ca9feea4b9cdd4f5d5bc144b57ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f976f80a20b3e5c2a64dd9da0a2648a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a2f976f80a20b3e5c2a64dd9da0a2648a">cMsgCreateNewMessage</a> (const void *vmsg)</td></tr>
<tr class="separator:a2f976f80a20b3e5c2a64dd9da0a2648a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bb3706d4c1cf31e44f1f9f1ccb78de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a77bb3706d4c1cf31e44f1f9f1ccb78de">cMsgCopyMessage</a> (const void *vmsg)</td></tr>
<tr class="separator:a77bb3706d4c1cf31e44f1f9f1ccb78de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8ef09efaaacfb7c007a8aeead0d103"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aae8ef09efaaacfb7c007a8aeead0d103">cMsgInitMessage</a> (void *vmsg)</td></tr>
<tr class="separator:aae8ef09efaaacfb7c007a8aeead0d103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f2a3e781de0f85bfb16c4cfb9dba3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1e3f2a3e781de0f85bfb16c4cfb9dba3">cMsgCreateResponseMessage</a> (const void *vmsg)</td></tr>
<tr class="separator:a1e3f2a3e781de0f85bfb16c4cfb9dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce032c8bdf39718197d7d6d2f9914d0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a5ce032c8bdf39718197d7d6d2f9914d0">cMsgCreateNullResponseMessage</a> (const void *vmsg)</td></tr>
<tr class="separator:a5ce032c8bdf39718197d7d6d2f9914d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375ef62e93bf9feb7195abd9257d11bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a375ef62e93bf9feb7195abd9257d11bb">cMsgWasSent</a> (const void *vmsg, int *hasBeenSent)</td></tr>
<tr class="separator:a375ef62e93bf9feb7195abd9257d11bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7995e48e5e280e505e37b4b5b72402c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ad7995e48e5e280e505e37b4b5b72402c">cMsgGetVersion</a> (const void *vmsg, int *version)</td></tr>
<tr class="separator:ad7995e48e5e280e505e37b4b5b72402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e02fcce345ec42440fc3ebc4c8881e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae0e02fcce345ec42440fc3ebc4c8881e">cMsgGetGetRequest</a> (const void *vmsg, int *getRequest)</td></tr>
<tr class="separator:ae0e02fcce345ec42440fc3ebc4c8881e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f219b4ff224c4899ffe2b14941de23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a01f219b4ff224c4899ffe2b14941de23">cMsgSetGetResponse</a> (void *vmsg, int getReponse)</td></tr>
<tr class="separator:a01f219b4ff224c4899ffe2b14941de23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdebb7832d494aacecf88ab381af5bfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#abdebb7832d494aacecf88ab381af5bfc">cMsgGetGetResponse</a> (const void *vmsg, int *getReponse)</td></tr>
<tr class="separator:abdebb7832d494aacecf88ab381af5bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5083e7b37722212b9eb94ff6f13753b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a5083e7b37722212b9eb94ff6f13753b3">cMsgSetNullGetResponse</a> (void *vmsg, int nullGetResponse)</td></tr>
<tr class="separator:a5083e7b37722212b9eb94ff6f13753b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b25010d5d27303d15288212e018a6c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a2b25010d5d27303d15288212e018a6c2">cMsgGetNullGetResponse</a> (const void *vmsg, int *nullGetResponse)</td></tr>
<tr class="separator:a2b25010d5d27303d15288212e018a6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ecf71837d95900cf511c9d0cd1f397"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a63ecf71837d95900cf511c9d0cd1f397">cMsgGetDomain</a> (const void *vmsg, const char **domain)</td></tr>
<tr class="separator:a63ecf71837d95900cf511c9d0cd1f397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c0eac1762db63b9e0507ea6204df47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae9c0eac1762db63b9e0507ea6204df47">cMsgGetPayloadText</a> (const void *vmsg, const char **payloadText)</td></tr>
<tr class="separator:ae9c0eac1762db63b9e0507ea6204df47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890729efc8b63d8af59e54f98298ac3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a890729efc8b63d8af59e54f98298ac3c">cMsgSetSubject</a> (void *vmsg, const char *subject)</td></tr>
<tr class="separator:a890729efc8b63d8af59e54f98298ac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd99fe965b1a18f041853f167e41d67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aebd99fe965b1a18f041853f167e41d67">cMsgGetSubject</a> (const void *vmsg, const char **subject)</td></tr>
<tr class="separator:aebd99fe965b1a18f041853f167e41d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed62a8b39b6992c56bf9cdbfb00f80f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a2ed62a8b39b6992c56bf9cdbfb00f80f">cMsgSetType</a> (void *vmsg, const char *type)</td></tr>
<tr class="separator:a2ed62a8b39b6992c56bf9cdbfb00f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5079c24edb7c920c07c6e24c1e4908f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac5079c24edb7c920c07c6e24c1e4908f">cMsgGetType</a> (const void *vmsg, const char **type)</td></tr>
<tr class="separator:ac5079c24edb7c920c07c6e24c1e4908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263231aeceba900e26f4b09f7d88f00a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a263231aeceba900e26f4b09f7d88f00a">cMsgSetText</a> (void *vmsg, const char *text)</td></tr>
<tr class="separator:a263231aeceba900e26f4b09f7d88f00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6b173d6ee98259bd9e2e3aeb9e1a34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1e6b173d6ee98259bd9e2e3aeb9e1a34">cMsgGetText</a> (const void *vmsg, const char **text)</td></tr>
<tr class="separator:a1e6b173d6ee98259bd9e2e3aeb9e1a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4c719e852b925e02cc43dc0c0a8c3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#afc4c719e852b925e02cc43dc0c0a8c3e">cMsgSetUserInt</a> (void *vmsg, int userInt)</td></tr>
<tr class="separator:afc4c719e852b925e02cc43dc0c0a8c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a6252706b0202d3920b8a78d6629f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a77a6252706b0202d3920b8a78d6629f0">cMsgGetUserInt</a> (const void *vmsg, int *userInt)</td></tr>
<tr class="separator:a77a6252706b0202d3920b8a78d6629f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8bbb7c3868d0b1c53721ea2c48683a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aaa8bbb7c3868d0b1c53721ea2c48683a">cMsgSetUserTime</a> (void *vmsg, const struct timespec *userTime)</td></tr>
<tr class="separator:aaa8bbb7c3868d0b1c53721ea2c48683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae709e7079a007ee88ebc0b41a4da8a7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae709e7079a007ee88ebc0b41a4da8a7b">cMsgGetUserTime</a> (const void *vmsg, struct timespec *userTime)</td></tr>
<tr class="separator:ae709e7079a007ee88ebc0b41a4da8a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0969391dfcd3cd8289eb04fc6399b602"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a0969391dfcd3cd8289eb04fc6399b602">cMsgGetSender</a> (const void *vmsg, const char **sender)</td></tr>
<tr class="separator:a0969391dfcd3cd8289eb04fc6399b602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65857ff0e87362d5098ca5e7c63961d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aa65857ff0e87362d5098ca5e7c63961d">cMsgGetSenderHost</a> (const void *vmsg, const char **senderHost)</td></tr>
<tr class="separator:aa65857ff0e87362d5098ca5e7c63961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d3b1e0b664616cb77b6966e0dce97e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac2d3b1e0b664616cb77b6966e0dce97e">cMsgGetSenderTime</a> (const void *vmsg, struct timespec *senderTime)</td></tr>
<tr class="separator:ac2d3b1e0b664616cb77b6966e0dce97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ea9c810a5e21db3fc7ee2a70c1fdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab74ea9c810a5e21db3fc7ee2a70c1fdd">cMsgGetReceiver</a> (const void *vmsg, const char **receiver)</td></tr>
<tr class="separator:ab74ea9c810a5e21db3fc7ee2a70c1fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af610fc6f5b12d664021f9bbddd83737c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#af610fc6f5b12d664021f9bbddd83737c">cMsgGetReceiverHost</a> (const void *vmsg, const char **receiverHost)</td></tr>
<tr class="separator:af610fc6f5b12d664021f9bbddd83737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5743b6b3fd75506c9ad40a0e840909d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a5743b6b3fd75506c9ad40a0e840909d2">cMsgGetReceiverTime</a> (const void *vmsg, struct timespec *receiverTime)</td></tr>
<tr class="separator:a5743b6b3fd75506c9ad40a0e840909d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b957b96d5723aeaae1b63a4075069d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a6b957b96d5723aeaae1b63a4075069d4">cMsgSetByteArrayLength</a> (void *vmsg, int length)</td></tr>
<tr class="separator:a6b957b96d5723aeaae1b63a4075069d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75519fd0576e1cc7ef8ff9eb333b7bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae75519fd0576e1cc7ef8ff9eb333b7bd">cMsgResetByteArrayLength</a> (void *vmsg)</td></tr>
<tr class="separator:ae75519fd0576e1cc7ef8ff9eb333b7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086309234f06d80deccb0b8229d22a6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a086309234f06d80deccb0b8229d22a6b">cMsgGetByteArrayLength</a> (const void *vmsg, int *length)</td></tr>
<tr class="separator:a086309234f06d80deccb0b8229d22a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f394c8f794a935d32377cfa4827591"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aa2f394c8f794a935d32377cfa4827591">cMsgGetByteArrayLengthFull</a> (const void *vmsg, int *length)</td></tr>
<tr class="separator:aa2f394c8f794a935d32377cfa4827591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82750dc5dcbb0630db7b9827190b8833"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a82750dc5dcbb0630db7b9827190b8833">cMsgSetByteArrayOffset</a> (void *vmsg, int offset)</td></tr>
<tr class="separator:a82750dc5dcbb0630db7b9827190b8833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c298192a9c6ac566e0a5094c98f68d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a0c298192a9c6ac566e0a5094c98f68d0">cMsgGetByteArrayOffset</a> (const void *vmsg, int *offset)</td></tr>
<tr class="separator:a0c298192a9c6ac566e0a5094c98f68d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549e77f6cc3fd844ecec74185a5c5551"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a549e77f6cc3fd844ecec74185a5c5551">cMsgSetByteArrayEndian</a> (void *vmsg, int endian)</td></tr>
<tr class="separator:a549e77f6cc3fd844ecec74185a5c5551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118367970210f0d7b28f7c5cad6f9115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a118367970210f0d7b28f7c5cad6f9115">cMsgGetByteArrayEndian</a> (const void *vmsg, int *endian)</td></tr>
<tr class="separator:a118367970210f0d7b28f7c5cad6f9115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7679f62347f3d049024cd767da4cbbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a7679f62347f3d049024cd767da4cbbcb">cMsgNeedToSwap</a> (const void *vmsg, int *swap)</td></tr>
<tr class="separator:a7679f62347f3d049024cd767da4cbbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b3d5d8af3c3f81a74ad0e27d74ef8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae7b3d5d8af3c3f81a74ad0e27d74ef8f">cMsgSetByteArray</a> (void *vmsg, char *array, int length)</td></tr>
<tr class="separator:ae7b3d5d8af3c3f81a74ad0e27d74ef8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51659c0d03d14d540d426a96e661800"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#af51659c0d03d14d540d426a96e661800">cMsgSetByteArrayNoCopy</a> (void *vmsg, char *array, int length)</td></tr>
<tr class="separator:af51659c0d03d14d540d426a96e661800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c3d89bdcb1c8dd313bff4127e84daa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae3c3d89bdcb1c8dd313bff4127e84daa">cMsgGetByteArray</a> (const void *vmsg, char **array)</td></tr>
<tr class="separator:ae3c3d89bdcb1c8dd313bff4127e84daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad249624d87a7577a8d6fa838278a68e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ad249624d87a7577a8d6fa838278a68e0">cMsgSetReliableSend</a> (void *vmsg, int boolean)</td></tr>
<tr class="separator:ad249624d87a7577a8d6fa838278a68e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90345420a9a31829151a88a35f3f5cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#af90345420a9a31829151a88a35f3f5cc">cMsgGetReliableSend</a> (void *vmsg, int *boolean)</td></tr>
<tr class="separator:af90345420a9a31829151a88a35f3f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0144cc0cb39c6a8e1e0d63942a58d16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#af0144cc0cb39c6a8e1e0d63942a58d16">cMsgGetSubscriptionDomain</a> (const void *vmsg, const char **domain)</td></tr>
<tr class="separator:af0144cc0cb39c6a8e1e0d63942a58d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87027a186787990d1494be0efd9bc56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aa87027a186787990d1494be0efd9bc56">cMsgGetSubscriptionSubject</a> (const void *vmsg, const char **subject)</td></tr>
<tr class="separator:aa87027a186787990d1494be0efd9bc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe0764303285ec69cbe96b2dfb8a37e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#acfe0764303285ec69cbe96b2dfb8a37e">cMsgGetSubscriptionType</a> (const void *vmsg, const char **type)</td></tr>
<tr class="separator:acfe0764303285ec69cbe96b2dfb8a37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173893c0ea87d53f715dc5d467788b4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a173893c0ea87d53f715dc5d467788b4e">cMsgGetSubscriptionUDL</a> (const void *vmsg, const char **udl)</td></tr>
<tr class="separator:a173893c0ea87d53f715dc5d467788b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad011394994f936cf5e59af00f9522255"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ad011394994f936cf5e59af00f9522255">cMsgGetSubscriptionCueSize</a> (const void *vmsg, int *size)</td></tr>
<tr class="separator:ad011394994f936cf5e59af00f9522255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870e71bbd742cc544d3f137712af7063"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a870e71bbd742cc544d3f137712af7063">cMsgToString</a> (const void *vmsg, char **string)</td></tr>
<tr class="separator:a870e71bbd742cc544d3f137712af7063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd12211e4b81a12bedfa8faa0fb862e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#acdd12211e4b81a12bedfa8faa0fb862e">cMsgToString2</a> (const void *vmsg, char **string, int binary, int compact, int noSystemFields)</td></tr>
<tr class="separator:acdd12211e4b81a12bedfa8faa0fb862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1194149886832c788ad3e5cec152423a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1194149886832c788ad3e5cec152423a">cMsgPayloadToString</a> (const void *vmsg, char **string, int binary, int compact, int noSystemFields)</td></tr>
<tr class="separator:a1194149886832c788ad3e5cec152423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b867224188eca1aa6f9c61ba868adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a04b867224188eca1aa6f9c61ba868adb">cMsgTrim</a> (char *s)</td></tr>
<tr class="separator:a04b867224188eca1aa6f9c61ba868adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1726f9ebefe2199ac38a60e35e0e1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ad1726f9ebefe2199ac38a60e35e0e1c7">cMsgTrimChar</a> (char *s, char trimChar)</td></tr>
<tr class="separator:ad1726f9ebefe2199ac38a60e35e0e1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0620f042ef32f864ed34dd47b9531ea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a0620f042ef32f864ed34dd47b9531ea7">cMsgTrimDoubleChars</a> (char *s, char trimChar)</td></tr>
<tr class="separator:a0620f042ef32f864ed34dd47b9531ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92338cd77d996904f35344a91d38c609"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a92338cd77d996904f35344a91d38c609">cMsgAddHistoryToPayloadText</a> (void *vmsg, char *name, char *host, int64_t time, char **pTxt)</td></tr>
<tr class="separator:a92338cd77d996904f35344a91d38c609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4d353630206fa691bdb413eafe5d35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aca4d353630206fa691bdb413eafe5d35">cMsgSetHistoryLengthMax</a> (void *vmsg, int len)</td></tr>
<tr class="separator:aca4d353630206fa691bdb413eafe5d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1e33b4645d96f5746fc496b9dff35c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#adc1e33b4645d96f5746fc496b9dff35c">cMsgGetHistoryLengthMax</a> (const void *vmsg, int *len)</td></tr>
<tr class="separator:adc1e33b4645d96f5746fc496b9dff35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217bc602d56d8b716f01b93aee829821"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a217bc602d56d8b716f01b93aee829821">cMsgPayloadGet</a> (const void *vmsg, char **names, int *types, int len)</td></tr>
<tr class="separator:a217bc602d56d8b716f01b93aee829821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880746983c824f0f211b457fdabfa781"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a880746983c824f0f211b457fdabfa781">cMsgPayloadGetInfo</a> (const void *vmsg, char ***names, int **types, int *len)</td></tr>
<tr class="separator:a880746983c824f0f211b457fdabfa781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ed21521fc461afebfdf137a55dd7c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a51ed21521fc461afebfdf137a55dd7c3">cMsgPayloadGetCount</a> (const void *vmsg, int *count)</td></tr>
<tr class="separator:a51ed21521fc461afebfdf137a55dd7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8a80b128fc6b33791d50f8dd8a9255"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a6f8a80b128fc6b33791d50f8dd8a9255">cMsgPayloadContainsName</a> (const void *vmsg, const char *name)</td></tr>
<tr class="separator:a6f8a80b128fc6b33791d50f8dd8a9255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8873fe9e6fcb574563a90fce2d79db4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a8873fe9e6fcb574563a90fce2d79db4a">cMsgPayloadGetType</a> (const void *vmsg, const char *name, int *type)</td></tr>
<tr class="separator:a8873fe9e6fcb574563a90fce2d79db4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3845e125913ca2f42afdeaca12cec2ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a3845e125913ca2f42afdeaca12cec2ff">cMsgPayloadRemove</a> (void *vmsg, const char *name)</td></tr>
<tr class="separator:a3845e125913ca2f42afdeaca12cec2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7564ac7969a9e7a82d49e96f756853c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac7564ac7969a9e7a82d49e96f756853c">cMsgPayloadCopy</a> (const void *vmsgFrom, void *vmsgTo)</td></tr>
<tr class="separator:ac7564ac7969a9e7a82d49e96f756853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7967cb13e1c6be8a7007689ca7f3b40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac7967cb13e1c6be8a7007689ca7f3b40">cMsgPayloadUpdateText</a> (const void *vmsg)</td></tr>
<tr class="separator:ac7967cb13e1c6be8a7007689ca7f3b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87048a62d5c0eac77232a252fed357c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a87048a62d5c0eac77232a252fed357c9">cMsgPayloadGetFieldText</a> (const void *vmsg, const char *name, const char **val)</td></tr>
<tr class="separator:a87048a62d5c0eac77232a252fed357c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7075e33ab6f0ca3d5806bc73284a5a40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a7075e33ab6f0ca3d5806bc73284a5a40">cMsgPayloadPrint</a> (const void *vmsg)</td></tr>
<tr class="separator:a7075e33ab6f0ca3d5806bc73284a5a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f24953e8dafd743f193fd79b6ad944b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a2f24953e8dafd743f193fd79b6ad944b">cMsgPayloadFieldDescription</a> (const void *vmsg, const char *name)</td></tr>
<tr class="separator:a2f24953e8dafd743f193fd79b6ad944b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8ebe24cd4dfce9270a0a70ff3e77c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a7c8ebe24cd4dfce9270a0a70ff3e77c4">cMsgPayloadSetFromText</a> (void *vmsg, const char *text)</td></tr>
<tr class="separator:a7c8ebe24cd4dfce9270a0a70ff3e77c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5c8070ff4c129830269c005fdedff4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a9c5c8070ff4c129830269c005fdedff4">cMsgPayloadSetSystemFieldsFromText</a> (void *vmsg, const char *text)</td></tr>
<tr class="separator:a9c5c8070ff4c129830269c005fdedff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0ad36a23bd14777a3e2cdd04aa3045"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a3e0ad36a23bd14777a3e2cdd04aa3045">cMsgPayloadSetAllFieldsFromText</a> (void *vmsg, const char *text)</td></tr>
<tr class="separator:a3e0ad36a23bd14777a3e2cdd04aa3045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1642a5fbfd664d9a1b813e6eed50282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac1642a5fbfd664d9a1b813e6eed50282">cMsgPayloadReset</a> (void *vmsg)</td></tr>
<tr class="separator:ac1642a5fbfd664d9a1b813e6eed50282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb257ec2a764410aea07ccfd86841957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#afb257ec2a764410aea07ccfd86841957">cMsgPayloadClear</a> (void *vmsg)</td></tr>
<tr class="separator:afb257ec2a764410aea07ccfd86841957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63472f68444bc42795e840b199d6d10e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a63472f68444bc42795e840b199d6d10e">cMsgHasPayload</a> (const void *vmsg, int *hasPayload)</td></tr>
<tr class="separator:a63472f68444bc42795e840b199d6d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9bd1ed0395f1a785cc9e95af3d864d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aac9bd1ed0395f1a785cc9e95af3d864d">cMsgGetBinary</a> (const void *vmsg, const char *name, const char **val, int *len, int *endian)</td></tr>
<tr class="separator:aac9bd1ed0395f1a785cc9e95af3d864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9555c3eb4c4029dc33490a375d3dc67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aa9555c3eb4c4029dc33490a375d3dc67">cMsgGetBinaryArray</a> (const void *vmsg, const char *name, const char ***vals, int **sizes, int **endians, int *count)</td></tr>
<tr class="separator:aa9555c3eb4c4029dc33490a375d3dc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5d1988c6f449f07df428b7d60d936a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#abf5d1988c6f449f07df428b7d60d936a">cMsgGetMessage</a> (const void *vmsg, const char *name, const void **val)</td></tr>
<tr class="separator:abf5d1988c6f449f07df428b7d60d936a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecc3570645ec81d55733aed8c3c6c2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a3ecc3570645ec81d55733aed8c3c6c2c">cMsgGetMessageArray</a> (const void *vmsg, const char *name, const void ***val, int *len)</td></tr>
<tr class="separator:a3ecc3570645ec81d55733aed8c3c6c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0f995cbe118bd5a5b3ab1549567ae1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a9b0f995cbe118bd5a5b3ab1549567ae1">cMsgGetString</a> (const void *vmsg, const char *name, const char **val)</td></tr>
<tr class="separator:a9b0f995cbe118bd5a5b3ab1549567ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd25e765e52bb1629490b9571a4f222"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#adfd25e765e52bb1629490b9571a4f222">cMsgGetStringArray</a> (const void *vmsg, const char *name, const char ***array, int *len)</td></tr>
<tr class="separator:adfd25e765e52bb1629490b9571a4f222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998b005eca1705f3d225bc84f08c3857"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a998b005eca1705f3d225bc84f08c3857">cMsgGetFloat</a> (const void *vmsg, const char *name, float *val)</td></tr>
<tr class="separator:a998b005eca1705f3d225bc84f08c3857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0d17da612a154c619919f0d22c9df4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#afb0d17da612a154c619919f0d22c9df4">cMsgGetFloatArray</a> (const void *vmsg, const char *name, const float **vals, int *len)</td></tr>
<tr class="separator:afb0d17da612a154c619919f0d22c9df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf33e545651c274b2d35d03d33ce7fd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#abf33e545651c274b2d35d03d33ce7fd1">cMsgGetDouble</a> (const void *vmsg, const char *name, double *val)</td></tr>
<tr class="separator:abf33e545651c274b2d35d03d33ce7fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3342d9b1ebe001d5e8cad17dc3327b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1d3342d9b1ebe001d5e8cad17dc3327b">cMsgGetDoubleArray</a> (const void *vmsg, const char *name, const double **vals, int *len)</td></tr>
<tr class="separator:a1d3342d9b1ebe001d5e8cad17dc3327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3331b6b38241b598694ac0d3540e05a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ad3331b6b38241b598694ac0d3540e05a">cMsgGetInt8</a> (const void *vmsg, const char *name, int8_t *val)</td></tr>
<tr class="separator:ad3331b6b38241b598694ac0d3540e05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab547c3a8e11197d69b8ace7ebfa53656"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab547c3a8e11197d69b8ace7ebfa53656">cMsgGetInt16</a> (const void *vmsg, const char *name, int16_t *val)</td></tr>
<tr class="separator:ab547c3a8e11197d69b8ace7ebfa53656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fbec1883ddf14631aae471ba127090"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac7fbec1883ddf14631aae471ba127090">cMsgGetInt32</a> (const void *vmsg, const char *name, int32_t *val)</td></tr>
<tr class="separator:ac7fbec1883ddf14631aae471ba127090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8e5bac3e395eae7fd35b9ed37b2ec1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#acb8e5bac3e395eae7fd35b9ed37b2ec1">cMsgGetInt64</a> (const void *vmsg, const char *name, int64_t *val)</td></tr>
<tr class="separator:acb8e5bac3e395eae7fd35b9ed37b2ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b28bd9bbb6ad32bbb981c72331e8e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a94b28bd9bbb6ad32bbb981c72331e8e5">cMsgGetUint8</a> (const void *vmsg, const char *name, uint8_t *val)</td></tr>
<tr class="separator:a94b28bd9bbb6ad32bbb981c72331e8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd5abe308dd88c7cd388eae6440cf61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1bd5abe308dd88c7cd388eae6440cf61">cMsgGetUint16</a> (const void *vmsg, const char *name, uint16_t *val)</td></tr>
<tr class="separator:a1bd5abe308dd88c7cd388eae6440cf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c19dd89c67d5b6bf4a58238c5871f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a76c19dd89c67d5b6bf4a58238c5871f4">cMsgGetUint32</a> (const void *vmsg, const char *name, uint32_t *val)</td></tr>
<tr class="separator:a76c19dd89c67d5b6bf4a58238c5871f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcd01a61333f69ace4eec677bf79cdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aabcd01a61333f69ace4eec677bf79cdc">cMsgGetUint64</a> (const void *vmsg, const char *name, uint64_t *val)</td></tr>
<tr class="separator:aabcd01a61333f69ace4eec677bf79cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbdb88590b14d9be7feca7dde8c6c78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1dbdb88590b14d9be7feca7dde8c6c78">cMsgGetInt8Array</a> (const void *vmsg, const char *name, const int8_t **vals, int *len)</td></tr>
<tr class="separator:a1dbdb88590b14d9be7feca7dde8c6c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1951b19ce69ee490a011f2003da3dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aec1951b19ce69ee490a011f2003da3dc">cMsgGetInt16Array</a> (const void *vmsg, const char *name, const int16_t **vals, int *len)</td></tr>
<tr class="separator:aec1951b19ce69ee490a011f2003da3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b365e48623efcbadab28c3dcd439931"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a5b365e48623efcbadab28c3dcd439931">cMsgGetInt32Array</a> (const void *vmsg, const char *name, const int32_t **vals, int *len)</td></tr>
<tr class="separator:a5b365e48623efcbadab28c3dcd439931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f847b59d27a6d96a63fe58840955542"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a4f847b59d27a6d96a63fe58840955542">cMsgGetInt64Array</a> (const void *vmsg, const char *name, const int64_t **vals, int *len)</td></tr>
<tr class="separator:a4f847b59d27a6d96a63fe58840955542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ffbac38eefd3cd901b46d3c651a6e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a48ffbac38eefd3cd901b46d3c651a6e5">cMsgGetUint8Array</a> (const void *vmsg, const char *name, const uint8_t **vals, int *len)</td></tr>
<tr class="separator:a48ffbac38eefd3cd901b46d3c651a6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1834d0566588ad7008b97c1f968dfc75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1834d0566588ad7008b97c1f968dfc75">cMsgGetUint16Array</a> (const void *vmsg, const char *name, const uint16_t **vals, int *len)</td></tr>
<tr class="separator:a1834d0566588ad7008b97c1f968dfc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fa438a529ee9ce27515c303b3082dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab5fa438a529ee9ce27515c303b3082dc">cMsgGetUint32Array</a> (const void *vmsg, const char *name, const uint32_t **vals, int *len)</td></tr>
<tr class="separator:ab5fa438a529ee9ce27515c303b3082dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8560cd6dce3fe52ae9ccedbfd9ee73c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab8560cd6dce3fe52ae9ccedbfd9ee73c">cMsgGetUint64Array</a> (const void *vmsg, const char *name, const uint64_t **vals, int *len)</td></tr>
<tr class="separator:ab8560cd6dce3fe52ae9ccedbfd9ee73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1456974717a1cb1ee148e74721938d93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1456974717a1cb1ee148e74721938d93">cMsgAddInt8</a> (void *vmsg, const char *name, int8_t val)</td></tr>
<tr class="separator:a1456974717a1cb1ee148e74721938d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d08d20d05d2d0bc29f1aa7ba5c73065"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a4d08d20d05d2d0bc29f1aa7ba5c73065">cMsgAddInt16</a> (void *vmsg, const char *name, int16_t val)</td></tr>
<tr class="separator:a4d08d20d05d2d0bc29f1aa7ba5c73065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe78ba3dca61f39f84b620089cbbb17c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#abe78ba3dca61f39f84b620089cbbb17c">cMsgAddInt32</a> (void *vmsg, const char *name, int32_t val)</td></tr>
<tr class="separator:abe78ba3dca61f39f84b620089cbbb17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d90f23a780855f15face4f86eaced"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab43d90f23a780855f15face4f86eaced">cMsgAddInt64</a> (void *vmsg, const char *name, int64_t val)</td></tr>
<tr class="separator:ab43d90f23a780855f15face4f86eaced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eba267413c3c5bd15ce34e029ea285c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a0eba267413c3c5bd15ce34e029ea285c">cMsgAddUint8</a> (void *vmsg, const char *name, uint8_t val)</td></tr>
<tr class="separator:a0eba267413c3c5bd15ce34e029ea285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8017e47dc758764a67d0a9bd1b1fda74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a8017e47dc758764a67d0a9bd1b1fda74">cMsgAddUint16</a> (void *vmsg, const char *name, uint16_t val)</td></tr>
<tr class="separator:a8017e47dc758764a67d0a9bd1b1fda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666feabf736cd3376d6e02e9faa648c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a666feabf736cd3376d6e02e9faa648c9">cMsgAddUint32</a> (void *vmsg, const char *name, uint32_t val)</td></tr>
<tr class="separator:a666feabf736cd3376d6e02e9faa648c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b0738ff6cb5cc00e2e523e0d666fd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a45b0738ff6cb5cc00e2e523e0d666fd8">cMsgAddUint64</a> (void *vmsg, const char *name, uint64_t val)</td></tr>
<tr class="separator:a45b0738ff6cb5cc00e2e523e0d666fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af973e80f6bcb0ab3c379c5629752a035"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#af973e80f6bcb0ab3c379c5629752a035">cMsgAddInt8Array</a> (void *vmsg, const char *name, const int8_t vals[], int len)</td></tr>
<tr class="separator:af973e80f6bcb0ab3c379c5629752a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1a047b88bdbc4fd9f168567e1b4ff4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a0a1a047b88bdbc4fd9f168567e1b4ff4">cMsgAddInt16Array</a> (void *vmsg, const char *name, const int16_t vals[], int len)</td></tr>
<tr class="separator:a0a1a047b88bdbc4fd9f168567e1b4ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26492115103328d062da5ffc28a69d1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a26492115103328d062da5ffc28a69d1b">cMsgAddInt32Array</a> (void *vmsg, const char *name, const int32_t vals[], int len)</td></tr>
<tr class="separator:a26492115103328d062da5ffc28a69d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c62ddc047b2e31367a0e134a017dc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab6c62ddc047b2e31367a0e134a017dc6">cMsgAddInt64Array</a> (void *vmsg, const char *name, const int64_t vals[], int len)</td></tr>
<tr class="separator:ab6c62ddc047b2e31367a0e134a017dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3290a48abe3d58ae2c394f258cb11a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aea3290a48abe3d58ae2c394f258cb11a">cMsgAddUint8Array</a> (void *vmsg, const char *name, const uint8_t vals[], int len)</td></tr>
<tr class="separator:aea3290a48abe3d58ae2c394f258cb11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d03e66bbc4d027d4c4fdd90378aacc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a8d03e66bbc4d027d4c4fdd90378aacc6">cMsgAddUint16Array</a> (void *vmsg, const char *name, const uint16_t vals[], int len)</td></tr>
<tr class="separator:a8d03e66bbc4d027d4c4fdd90378aacc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67d39308a674f7efcfc6926ec892e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ac67d39308a674f7efcfc6926ec892e2f">cMsgAddUint32Array</a> (void *vmsg, const char *name, const uint32_t vals[], int len)</td></tr>
<tr class="separator:ac67d39308a674f7efcfc6926ec892e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2a8286df3e5297b71a2b16960d9f08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#acb2a8286df3e5297b71a2b16960d9f08">cMsgAddUint64Array</a> (void *vmsg, const char *name, const uint64_t vals[], int len)</td></tr>
<tr class="separator:acb2a8286df3e5297b71a2b16960d9f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798e7ceff437f6e0fa87ba06f67286fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a798e7ceff437f6e0fa87ba06f67286fd">cMsgAddString</a> (void *vmsg, const char *name, const char *val)</td></tr>
<tr class="separator:a798e7ceff437f6e0fa87ba06f67286fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe72721920fffa2f0fdceca7a06651ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#abe72721920fffa2f0fdceca7a06651ee">cMsgAddStringArray</a> (void *vmsg, const char *name, const char **vals, int len)</td></tr>
<tr class="separator:abe72721920fffa2f0fdceca7a06651ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9321d92e7dc2b47b0e7010476d47141f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a9321d92e7dc2b47b0e7010476d47141f">cMsgAddFloat</a> (void *vmsg, const char *name, float val)</td></tr>
<tr class="separator:a9321d92e7dc2b47b0e7010476d47141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717b89e02f79791855db29018a8dc3c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a717b89e02f79791855db29018a8dc3c5">cMsgAddDouble</a> (void *vmsg, const char *name, double val)</td></tr>
<tr class="separator:a717b89e02f79791855db29018a8dc3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac2e5c161174f1b34f478fc4ea63214"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a3ac2e5c161174f1b34f478fc4ea63214">cMsgAddFloatArray</a> (void *vmsg, const char *name, const float vals[], int len)</td></tr>
<tr class="separator:a3ac2e5c161174f1b34f478fc4ea63214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fd3d2200093d89deb04ebc461374db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aa7fd3d2200093d89deb04ebc461374db">cMsgAddDoubleArray</a> (void *vmsg, const char *name, const double vals[], int len)</td></tr>
<tr class="separator:aa7fd3d2200093d89deb04ebc461374db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfa480567336dc81d0204ace2b8a15c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#afdfa480567336dc81d0204ace2b8a15c">cMsgAddBinary</a> (void *vmsg, const char *name, const char *src, int size, int endian)</td></tr>
<tr class="separator:afdfa480567336dc81d0204ace2b8a15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17289a14a99e2d1a810a0a03e5c92cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aa17289a14a99e2d1a810a0a03e5c92cd">cMsgAddBinaryArray</a> (void *vmsg, const char *name, const char *src[], int number, const int size[], const int endian[])</td></tr>
<tr class="separator:aa17289a14a99e2d1a810a0a03e5c92cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9c19de4d0fc53c075a4f5819b96e8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aae9c19de4d0fc53c075a4f5819b96e8a">cMsgAddMessage</a> (void *vmsg, const char *name, const void *vmessage)</td></tr>
<tr class="separator:aae9c19de4d0fc53c075a4f5819b96e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1624fedd817da64bf47a7cf49a38eb16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1624fedd817da64bf47a7cf49a38eb16">cMsgAddMessageArray</a> (void *vmsg, const char *name, const void *vmessage[], int len)</td></tr>
<tr class="separator:a1624fedd817da64bf47a7cf49a38eb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab189d634a2302c007f1bcc26b8a86087"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ab189d634a2302c007f1bcc26b8a86087">cMsgFloatChars</a> (float f)</td></tr>
<tr class="separator:ab189d634a2302c007f1bcc26b8a86087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca1aa53c78ac2dac880d89992484df4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aeca1aa53c78ac2dac880d89992484df4">cMsgDoubleChars</a> (double d)</td></tr>
<tr class="separator:aeca1aa53c78ac2dac880d89992484df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd41627b445c05a91a04e32cc20492"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aa3bd41627b445c05a91a04e32cc20492">cMsgIntChars</a> (uint32_t i)</td></tr>
<tr class="separator:aa3bd41627b445c05a91a04e32cc20492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8900e00f1d6651aa96547b19e2fb0005"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a8900e00f1d6651aa96547b19e2fb0005">cMsgGetUDL</a> (void *domainId, char **udl)</td></tr>
<tr class="separator:a8900e00f1d6651aa96547b19e2fb0005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9b5fe19b27451658aefbb62f0f138b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a7c9b5fe19b27451658aefbb62f0f138b">cMsgGetName</a> (void *domainId, char **name)</td></tr>
<tr class="separator:a7c9b5fe19b27451658aefbb62f0f138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1820f554cad254ee20a559a409c47725"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a1820f554cad254ee20a559a409c47725">cMsgGetDescription</a> (void *domainId, char **description)</td></tr>
<tr class="separator:a1820f554cad254ee20a559a409c47725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9945b6ed528879a54cbc0611373a8f71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a9945b6ed528879a54cbc0611373a8f71">cMsgGetReceiveState</a> (void *domainId, int *receiveState)</td></tr>
<tr class="separator:a9945b6ed528879a54cbc0611373a8f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d0b394963dec7f2c61111d0c0568e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#abc4d0b394963dec7f2c61111d0c0568e">cMsgSubscribeConfigCreate</a> (void)</td></tr>
<tr class="separator:abc4d0b394963dec7f2c61111d0c0568e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d045c6bbb85efe3e94227acc1153072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a9d045c6bbb85efe3e94227acc1153072">cMsgSubscribeConfigDestroy</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config)</td></tr>
<tr class="separator:a9d045c6bbb85efe3e94227acc1153072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47b52751025fdb3588d2947b085eb3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae47b52751025fdb3588d2947b085eb3e">cMsgSubscribeSetMaxCueSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int size)</td></tr>
<tr class="separator:ae47b52751025fdb3588d2947b085eb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1805ff17bd33dfb0a93049417d07bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a6a1805ff17bd33dfb0a93049417d07bb">cMsgSubscribeGetMaxCueSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *size)</td></tr>
<tr class="separator:a6a1805ff17bd33dfb0a93049417d07bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da5fb98446bf42337fdaf4a11414929"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a7da5fb98446bf42337fdaf4a11414929">cMsgSubscribeSetSkipSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int size)</td></tr>
<tr class="separator:a7da5fb98446bf42337fdaf4a11414929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12842dac9c2dadf7d7713a85b7b28f88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a12842dac9c2dadf7d7713a85b7b28f88">cMsgSubscribeGetSkipSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *size)</td></tr>
<tr class="separator:a12842dac9c2dadf7d7713a85b7b28f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529a2d3840fa660988641dc5b197cc44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a529a2d3840fa660988641dc5b197cc44">cMsgSubscribeSetMaySkip</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int maySkip)</td></tr>
<tr class="separator:a529a2d3840fa660988641dc5b197cc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bed7080ef38765b1d68ef8740aedb11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a2bed7080ef38765b1d68ef8740aedb11">cMsgSubscribeGetMaySkip</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *maySkip)</td></tr>
<tr class="separator:a2bed7080ef38765b1d68ef8740aedb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52cae1f0be6c43c9f491c6a7128db0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int serialize)</td></tr>
<tr class="separator:aea52cae1f0be6c43c9f491c6a7128db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9415e46ee1b516b010cf5eef28666c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a8b9415e46ee1b516b010cf5eef28666c">cMsgSubscribeGetMustSerialize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *serialize)</td></tr>
<tr class="separator:a8b9415e46ee1b516b010cf5eef28666c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69abb5bcff7d143799192fb12646de06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a69abb5bcff7d143799192fb12646de06">cMsgSubscribeSetMaxThreads</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int threads)</td></tr>
<tr class="separator:a69abb5bcff7d143799192fb12646de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc108298020f8e3c71ff33f7a96d3b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a7dc108298020f8e3c71ff33f7a96d3b2">cMsgSubscribeGetMaxThreads</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *threads)</td></tr>
<tr class="separator:a7dc108298020f8e3c71ff33f7a96d3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac01109573ba8542848272978e0c627c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#aac01109573ba8542848272978e0c627c">cMsgSubscribeSetMessagesPerThread</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int mpt)</td></tr>
<tr class="separator:aac01109573ba8542848272978e0c627c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e8922c48e59728cccf3d042b04f56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#afe1e8922c48e59728cccf3d042b04f56">cMsgSubscribeGetMessagesPerThread</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, int *mpt)</td></tr>
<tr class="separator:afe1e8922c48e59728cccf3d042b04f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d900c90f49e384fe2b8133f6db0a37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#af4d900c90f49e384fe2b8133f6db0a37">cMsgSubscribeSetStackSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, size_t size)</td></tr>
<tr class="separator:af4d900c90f49e384fe2b8133f6db0a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddeab46092de2ccb0e84eacab7046dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#a0ddeab46092de2ccb0e84eacab7046dd">cMsgSubscribeGetStackSize</a> (<a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *config, size_t *size)</td></tr>
<tr class="separator:a0ddeab46092de2ccb0e84eacab7046dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43c67e4ed6b1f7118344ac9d5321e07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d52/c_msg_8h.html#ae43c67e4ed6b1f7118344ac9d5321e07">cMsgSetDebugLevel</a> (int level)</td></tr>
<tr class="separator:ae43c67e4ed6b1f7118344ac9d5321e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the one necessary header file for all cMsg C users. C++ users must include cMsg.hxx instead, which includes this file.</p>
<p><b>INTRODUCTION</b></p>
<p>cMsg is a simple, abstract API to an arbitrary underlying message service. It is powerful enough to support synchronous and asynchronous point-to-point and publish/subscribe communication, and network-accessible message queues. Note that a given underlying implementation may not necessarily implement all these features. <br  />
</p>
<p><b>DOMAINS</b></p>
<p>The abstraction relies on the important concept of a "domain", specified via a "Universal Domain Locator" (UDL) of the form:</p>
<p><code><b>cMsg:domainType://domainInfo</b></code></p>
<p>The domain type refers to an underlying messaging software implementation, and the domain info is interpreted by the implementation. Generally domains with different UDL's are isolated from each other, but this is not necessarily the case. For example, users can easily create gateways between different domains, or different domain servers may serve into the same messaging namespace.</p>
<p>The full domain specifier for the full cMsg domain looks like:</p>
<p><code><b>cMsg:cMsg://node:port/cMsg/namespace?param1=val1(&amp;param2=val2)</b></code></p>
<p>where node:port correspond to the node and port of a cMsg nameserver, and namespace allows for multiple namespaces on the same server. If the port is missing a default port is used. Parameters are optional and not specified at this time. Currently different cMsg domains are completely isolated from each other. A process can connect to multiple domains if desired.</p>
<p><b>MESSAGES</b></p>
<p>Messages are sent via <a class="el" href="../../d5/d52/c_msg_8h.html#ac0e85fe096860040adfeed9a8fffe175">cMsgSend()</a> and related functions. Messages have a type and are sent to a subject, and both are arbitrary strings. The payload consists of a single text string. Users must call <a class="el" href="../../d5/d52/c_msg_8h.html#adab9134878cc0058e9ae3128a445ff00">cMsgFlush()</a> to initiate delivery of messages in the outbound send queues, although the implementation may deliver messages before <a class="el" href="../../d5/d52/c_msg_8h.html#adab9134878cc0058e9ae3128a445ff00">cMsgFlush()</a> is called. Additional message meta-data may be set by the user (see below), although much of it is set by the system.</p>
<p>Message consumers ask the system to deliver messages to them that match various subject/type combinations (each may be NULL). The messages are delivered asynchronously to callbacks (via <a class="el" href="../../d5/d52/c_msg_8h.html#a5d422d9f2f693414868af48a16d13649">cMsgSubscribe()</a>). <a class="el" href="../../d5/d52/c_msg_8h.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a> must be called when the user is done processing the message. Synchronous or RPC-like messaging is also possible via <a class="el" href="../../d5/d52/c_msg_8h.html#ad7b774e764c900e8f742102923642950">cMsgSendAndGet()</a>.</p>
<p><a class="el" href="../../d5/d52/c_msg_8h.html#aca2d833b870683ee4c130056f4d12673">cMsgReceiveStart()</a> must be called to start delivery of messages to callbacks. <br  />
</p>
<p>In the cMsg domain perl-like subject wildcard characters are supported, multiple callbacks for the same subject/type are allowed, and each callback executes in its own thread.</p>
<p><b>ADDITIONAL INFORMATION</b></p>
<p>See the cMsg User's Guide and the cMsg Developer's Guide for more information. See the cMsg Doxygen and Java docs for the full API specification. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a2a5df4825a5a9beee6877d4e3c96f491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5df4825a5a9beee6877d4e3c96f491">&#9670;&nbsp;</a></span>cMsgCallbackFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() cMsgCallbackFunc(void *msg, void *userArg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function. </p>

</div>
</div>
<a id="a13c894556c5124a6f408f1b5266b414d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c894556c5124a6f408f1b5266b414d">&#9670;&nbsp;</a></span>cMsgShutdownHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() cMsgShutdownHandler(void *userArg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shutdown handler function. </p>

</div>
</div>
<a id="a2df480a6bce32c360ad07d5e35e3b5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df480a6bce32c360ad07d5e35e3b5c9">&#9670;&nbsp;</a></span>cMsgSubscribeConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subscribe configuration. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afdfa480567336dc81d0204ace2b8a15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfa480567336dc81d0204ace2b8a15c">&#9670;&nbsp;</a></span>cMsgAddBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddBinary </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named field of binary data to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">src</td><td>pointer to binary data to add </td></tr>
    <tr><td class="paramname">size</td><td>size in bytes of data to add </td></tr>
    <tr><td class="paramname">endian</td><td>endian value of binary data, may be CMSG_ENDIAN_BIG, CMSG_ENDIAN_LITTLE, CMSG_ENDIAN_LOCAL, or CMSG_ENDIAN_NOTLOCAL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if cannot find local endian </dd>
<dd>
CMSG_BAD_ARGUMENT if message, src or name is NULL, size &lt; 1, or endian != CMSG_ENDIAN_BIG, CMSG_ENDIAN_LITTLE, CMSG_ENDIAN_LOCAL, or CMSG_ENDIAN_NOTLOCAL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="aa17289a14a99e2d1a810a0a03e5c92cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17289a14a99e2d1a810a0a03e5c92cd">&#9670;&nbsp;</a></span>cMsgAddBinaryArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddBinaryArray </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>endian</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named field of binary data to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">src</td><td>pointer to array of binary data arrays to add </td></tr>
    <tr><td class="paramname">number</td><td>number of arrays of binary data to add </td></tr>
    <tr><td class="paramname">size</td><td>array of sizes in bytes of binary data arrays to add </td></tr>
    <tr><td class="paramname">endian</td><td>array of endian values of binary data arrays, may be CMSG_ENDIAN_BIG, CMSG_ENDIAN_LITTLE, CMSG_ENDIAN_LOCAL, or CMSG_ENDIAN_NOTLOCAL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if cannot find local endian </dd>
<dd>
CMSG_BAD_ARGUMENT if message, src or name is NULL, size &lt; 1, or endian != CMSG_ENDIAN_BIG, CMSG_ENDIAN_LITTLE, CMSG_ENDIAN_LOCAL, or CMSG_ENDIAN_NOTLOCAL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed, or if error in binary-to-text transformation </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a717b89e02f79791855db29018a8dc3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717b89e02f79791855db29018a8dc3c5">&#9670;&nbsp;</a></span>cMsgAddDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddDouble </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, double field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>double to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="aa7fd3d2200093d89deb04ebc461374db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fd3d2200093d89deb04ebc461374db">&#9670;&nbsp;</a></span>cMsgAddDoubleArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddDoubleArray </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, double array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of doubles to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of doubles from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, name, or vals is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a9321d92e7dc2b47b0e7010476d47141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9321d92e7dc2b47b0e7010476d47141f">&#9670;&nbsp;</a></span>cMsgAddFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddFloat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, float field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>float to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a3ac2e5c161174f1b34f478fc4ea63214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac2e5c161174f1b34f478fc4ea63214">&#9670;&nbsp;</a></span>cMsgAddFloatArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddFloatArray </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, float array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of floats to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of floats from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, name, or vals is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a92338cd77d996904f35344a91d38c609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92338cd77d996904f35344a91d38c609">&#9670;&nbsp;</a></span>cMsgAddHistoryToPayloadText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddHistoryToPayloadText </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>pTxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds arguments to the history of senders, senderHosts, and senderTimes of this message (in the payload). This method only keeps cMsgMessage_t.historyLengthMax number of the most recent names. This method is reserved for system use only.</p>
<p>When a client sends the same message over and over again, we do <b>NOT</b> want the history to change. To ensure this, we follow a simple principle: the sender history needs to go into the sent message (ie. over the wire), but must not be added to the local one. Thus, if I send a message, its local sender history will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of sender to add to the history of senders </td></tr>
    <tr><td class="paramname">host</td><td>name of sender host to add to the history of hosts </td></tr>
    <tr><td class="paramname">time</td><td>sender time to add to the history of times </td></tr>
    <tr><td class="paramname">pTxt</td><td>pointer filled with text representation of payload with the history items added (memory is allocated)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if error in internal details of existing history payload items </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

<p class="reference">References <a class="el" href="../../d1/dfc/c_msg_compound_payload_8c.html#a6f8a80b128fc6b33791d50f8dd8a9255">cMsgPayloadContainsName()</a>.</p>

</div>
</div>
<a id="a4d08d20d05d2d0bc29f1aa7ba5c73065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d08d20d05d2d0bc29f1aa7ba5c73065">&#9670;&nbsp;</a></span>cMsgAddInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddInt16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 16-bit, signed int field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>value of 16-bit, signed int to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a0a1a047b88bdbc4fd9f168567e1b4ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1a047b88bdbc4fd9f168567e1b4ff4">&#9670;&nbsp;</a></span>cMsgAddInt16Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddInt16Array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 16-bit, signed int array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of 16-bit, signed ints to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of ints from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="abe78ba3dca61f39f84b620089cbbb17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe78ba3dca61f39f84b620089cbbb17c">&#9670;&nbsp;</a></span>cMsgAddInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddInt32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 32-bit, signed int field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>value of 32-bit, signed int to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a26492115103328d062da5ffc28a69d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26492115103328d062da5ffc28a69d1b">&#9670;&nbsp;</a></span>cMsgAddInt32Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddInt32Array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 32-bit, signed int array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of 32-bit, signed ints to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of ints from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="ab43d90f23a780855f15face4f86eaced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43d90f23a780855f15face4f86eaced">&#9670;&nbsp;</a></span>cMsgAddInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddInt64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 64-bit, signed int field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>value of 64-bit, signed int to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="ab6c62ddc047b2e31367a0e134a017dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c62ddc047b2e31367a0e134a017dc6">&#9670;&nbsp;</a></span>cMsgAddInt64Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddInt64Array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 64-bit, signed int array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of 64-bit, signed ints to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of ints from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a1456974717a1cb1ee148e74721938d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1456974717a1cb1ee148e74721938d93">&#9670;&nbsp;</a></span>cMsgAddInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddInt8 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 8-bit, signed int field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>value of 8-bit, signed int to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="af973e80f6bcb0ab3c379c5629752a035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af973e80f6bcb0ab3c379c5629752a035">&#9670;&nbsp;</a></span>cMsgAddInt8Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddInt8Array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 8-bit, signed int array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of 8-bit, signed ints to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of ints from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="aae9c19de4d0fc53c075a4f5819b96e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9c19de4d0fc53c075a4f5819b96e8a">&#9670;&nbsp;</a></span>cMsgAddMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddMessage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named cMsg message field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes. The string representation of the message is the same format as that used for a complete compound payload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vmessage</td><td>cMsg message to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed, or if error in binary-to-text transformation </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a1624fedd817da64bf47a7cf49a38eb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1624fedd817da64bf47a7cf49a38eb16">&#9670;&nbsp;</a></span>cMsgAddMessageArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddMessageArray </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmessage</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named field of an array of cMsg messages to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vmessage</td><td>array of cMsg messages to add </td></tr>
    <tr><td class="paramname">len</td><td>number of messages from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message array, src, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed, or if error in binary-to-text transformation </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a798e7ceff437f6e0fa87ba06f67286fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798e7ceff437f6e0fa87ba06f67286fd">&#9670;&nbsp;</a></span>cMsgAddString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddString </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named string field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>string to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, val or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="abe72721920fffa2f0fdceca7a06651ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe72721920fffa2f0fdceca7a06651ee">&#9670;&nbsp;</a></span>cMsgAddStringArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddStringArray </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named string array field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>strings to add </td></tr>
    <tr><td class="paramname">len</td><td>number of strings to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a8017e47dc758764a67d0a9bd1b1fda74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8017e47dc758764a67d0a9bd1b1fda74">&#9670;&nbsp;</a></span>cMsgAddUint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddUint16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 16-bit, unsigned int field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>value of 16-bit, unsigned int to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a8d03e66bbc4d027d4c4fdd90378aacc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d03e66bbc4d027d4c4fdd90378aacc6">&#9670;&nbsp;</a></span>cMsgAddUint16Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddUint16Array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 16-bit, unsigned int array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of 16-bit, unsigned ints to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of ints from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a666feabf736cd3376d6e02e9faa648c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666feabf736cd3376d6e02e9faa648c9">&#9670;&nbsp;</a></span>cMsgAddUint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddUint32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 32-bit, unsigned int field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>value of 32-bit, unsigned int to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="ac67d39308a674f7efcfc6926ec892e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67d39308a674f7efcfc6926ec892e2f">&#9670;&nbsp;</a></span>cMsgAddUint32Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddUint32Array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 32-bit, unsigned int array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of 32-bit, unsigned ints to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of ints from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a45b0738ff6cb5cc00e2e523e0d666fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b0738ff6cb5cc00e2e523e0d666fd8">&#9670;&nbsp;</a></span>cMsgAddUint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddUint64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 64-bit, unsigned int field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>value of 64-bit, unsigned int to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="acb2a8286df3e5297b71a2b16960d9f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2a8286df3e5297b71a2b16960d9f08">&#9670;&nbsp;</a></span>cMsgAddUint64Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddUint64Array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 64-bit, unsigned int array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of 64-bit, unsigned ints to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of ints from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="a0eba267413c3c5bd15ce34e029ea285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eba267413c3c5bd15ce34e029ea285c">&#9670;&nbsp;</a></span>cMsgAddUint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddUint8 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 8-bit, unsigned int field to the compound payload of a message. Names may not begin with "cmsg" (case insensitive), be longer than CMSG_PAYLOAD_NAME_LEN, or contain white space or quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">val</td><td>value of 8-bit, unsigned int to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message or name is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="aea3290a48abe3d58ae2c394f258cb11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3290a48abe3d58ae2c394f258cb11a">&#9670;&nbsp;</a></span>cMsgAddUint8Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgAddUint8Array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine adds a named, 8-bit, unsigned int array field to the compound payload of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to add </td></tr>
    <tr><td class="paramname">vals</td><td>array of 8-bit, unsigned ints to add (copy) </td></tr>
    <tr><td class="paramname">len</td><td>number of ints from array to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message, vals, or name is NULL; len &lt; 1 </dd>
<dd>
CMSG_OUT_OF_MEMORY if no more memory </dd>
<dd>
CMSG_BAD_FORMAT if name is not properly formed </dd>
<dd>
CMSG_ALREADY_EXISTS if name is being used already </dd></dl>

</div>
</div>
<a id="acc8551bd36bdc8138c0c9574daa3d1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8551bd36bdc8138c0c9574daa3d1fc">&#9670;&nbsp;</a></span>cMsgConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgConnect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>myUDL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>myName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>myDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>domainId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine is called once to connect to a domain. The argument "myUDL" is the Universal Domain Locator used to uniquely identify the cMsg server to connect to. It has the form:</p>
<p><b><em>cMsg:domainType://domainInfo </em></b></p>
<p>The argument "myName" is the client's name and may be required to be unique within the domain depending on the domain. The argument "myDescription" is an arbitrary string used to describe the client. If successful, this routine fills the argument "domainId", which identifies the connection uniquely and is required as an argument by many other routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myUDL</td><td>the Universal Domain Locator used to uniquely identify the cMsg server to connect to </td></tr>
    <tr><td class="paramname">myName</td><td>name of this client </td></tr>
    <tr><td class="paramname">myDescription</td><td>description of this client </td></tr>
    <tr><td class="paramname">domainId</td><td>pointer to pointer which gets filled with a unique id referring to this connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if regular expression compilation fails during UDL parsing or circular UDL references </dd>
<dd>
CMSG_BAD_ARGUMENT if one of the arguments is bad </dd>
<dd>
CMSG_BAD_FORMAT if the UDL is formatted incorrectly </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory (allocated or static) </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgConnect </dd></dl>

</div>
</div>
<a id="a77bb3706d4c1cf31e44f1f9f1ccb78de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bb3706d4c1cf31e44f1f9f1ccb78de">&#9670;&nbsp;</a></span>cMsgCopyMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCopyMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine copies a message. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>. If the given message has a byte array that was copied in, it is copied again into the new message. Otherwise, if it has a byte array whose pointer was copied, the new message will point to the same byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message structure being copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the message copy </dd>
<dd>
NULL if argument is NULL or no memory available </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d6/de2/c_msg_8c.html#a2f976f80a20b3e5c2a64dd9da0a2648a">cMsgCreateNewMessage()</a>.</p>

</div>
</div>
<a id="a06e3ca9feea4b9cdd4f5d5bc144b57ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e3ca9feea4b9cdd4f5d5bc144b57ce">&#9670;&nbsp;</a></span>cMsgCreateMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCreateMessage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine creates a new, initialized message. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new message </dd>
<dd>
NULL if no memory available </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d6/de2/c_msg_8c.html#a5ce032c8bdf39718197d7d6d2f9914d0">cMsgCreateNullResponseMessage()</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a1e3f2a3e781de0f85bfb16c4cfb9dba3">cMsgCreateResponseMessage()</a>.</p>

</div>
</div>
<a id="a2f976f80a20b3e5c2a64dd9da0a2648a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f976f80a20b3e5c2a64dd9da0a2648a">&#9670;&nbsp;</a></span>cMsgCreateNewMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCreateNewMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine copies the given message, clears the history, and is marked as NOT having been sent. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message being copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new message </dd>
<dd>
NULL if no memory available or message argument is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../d6/de2/c_msg_8c.html#a77bb3706d4c1cf31e44f1f9f1ccb78de">cMsgCopyMessage()</a>.</p>

</div>
</div>
<a id="a5ce032c8bdf39718197d7d6d2f9914d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce032c8bdf39718197d7d6d2f9914d0">&#9670;&nbsp;</a></span>cMsgCreateNullResponseMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCreateNullResponseMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine creates a new, initialized message with some fields copied from the given message in order to make it a proper "NULL" (or no message) response to a sendAndGet() request. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message to which response fields are set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new message </dd>
<dd>
NULL if no memory available, message argument is NULL, or message argument is not from calling sendAndGet() </dd></dl>

<p class="reference">References <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>.</p>

</div>
</div>
<a id="a1e3f2a3e781de0f85bfb16c4cfb9dba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3f2a3e781de0f85bfb16c4cfb9dba3">&#9670;&nbsp;</a></span>cMsgCreateResponseMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cMsgCreateResponseMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine creates a new, initialized message with some fields copied from the given message in order to make it a proper response to a sendAndGet() request. Memory is allocated with this function and can be freed by <a class="el" href="../../d6/de2/c_msg_8c.html#ad5f804fe6777fdc77fbd35fceac93bdb">cMsgFreeMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message to which response fields are set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new message </dd>
<dd>
NULL if no memory available, message argument is NULL, or message argument is not from calling sendAndGet() </dd></dl>

<p class="reference">References <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>.</p>

</div>
</div>
<a id="a86b9114fb29704d0e2d64c22e6287adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b9114fb29704d0e2d64c22e6287adc">&#9670;&nbsp;</a></span>cMsgDisconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgDisconnect </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine disconnects the client from the cMsg server. May only call this once if it succeeds since it frees memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>address of domain connection id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if this routine already called for the given domainId </dd>
<dd>
CMSG_BAD_ARGUMENT if the domainId or the pointer it refers to is NULL, or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
CMSG_LOST_CONNECTION if no longer connected to domain </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgDisconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="aeca1aa53c78ac2dac880d89992484df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca1aa53c78ac2dac880d89992484df4">&#9670;&nbsp;</a></span>cMsgDoubleChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cMsgDoubleChars </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a string representation of a double in the form of 16 hex chars of the IEEE754 representation. String points to internal static character array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>double value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hex characters rep of IEEE765 bytes </dd></dl>

</div>
</div>
<a id="ab189d634a2302c007f1bcc26b8a86087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab189d634a2302c007f1bcc26b8a86087">&#9670;&nbsp;</a></span>cMsgFloatChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cMsgFloatChars </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a string representation of a float in the form of 8 hex chars of the IEEE754 representation. String points to internal static character array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>float value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hex characters rep of IEEE765 bytes </dd></dl>

</div>
</div>
<a id="adab9134878cc0058e9ae3128a445ff00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab9134878cc0058e9ae3128a445ff00">&#9670;&nbsp;</a></span>cMsgFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgFlush </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends any pending (queued up) communication with the server. The implementation of this routine depends entirely on the domain in which it is being used. In the cMsg domain, this routine does nothing as all server communications are sent immediately upon calling any function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">timeout</td><td>amount of time to wait for completion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgFlush </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ad5f804fe6777fdc77fbd35fceac93bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f804fe6777fdc77fbd35fceac93bdb">&#9670;&nbsp;</a></span>cMsgFreeMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgFreeMessage </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine frees the memory allocated in the creation of a message. The cMsg client must call this routine on any messages created to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>address of pointer to message structure being freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if msg is NULL </dd></dl>

</div>
</div>
<a id="aac9bd1ed0395f1a785cc9e95af3d864d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9bd1ed0395f1a785cc9e95af3d864d">&#9670;&nbsp;</a></span>cMsgGetBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetBinary </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the value of the given field as binary (byte array) if it exists. Do NOT write into the returned pointer's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value </td></tr>
    <tr><td class="paramname">size</td><td>pointer filled with number of bytes in binary array </td></tr>
    <tr><td class="paramname">endian</td><td>pointer filled with endian of data (CMSG_ENDIAN_BIG/LITTLE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="aa9555c3eb4c4029dc33490a375d3dc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9555c3eb4c4029dc33490a375d3dc67">&#9670;&nbsp;</a></span>cMsgGetBinaryArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetBinaryArray </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char ***&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>endians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the value of the given field as an array of binary data (array of byte arrays) if it exists. Do NOT write into the returned pointer's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with array of byte arrays </td></tr>
    <tr><td class="paramname">sizes</td><td>pointer filled with array of number of bytes in byte arrays </td></tr>
    <tr><td class="paramname">endians</td><td>pointer filled with array of endian of data in byte arrays (CMSG_ENDIAN_BIG/LITTLE) </td></tr>
    <tr><td class="paramname">count</td><td>pointer filled with number of element in each returned array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="ae3c3d89bdcb1c8dd313bff4127e84daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c3d89bdcb1c8dd313bff4127e84daa">&#9670;&nbsp;</a></span>cMsgGetByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArray </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets a message's byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">array</td><td>pointer to be filled with byte array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a118367970210f0d7b28f7c5cad6f9115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118367970210f0d7b28f7c5cad6f9115">&#9670;&nbsp;</a></span>cMsgGetByteArrayEndian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArrayEndian </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the endianness of the byte array data. Valid returned values are: </p><ul>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">endian</td><td>int pointer to be filled with byte array data endianness</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a086309234f06d80deccb0b8229d22a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086309234f06d80deccb0b8229d22a6b">&#9670;&nbsp;</a></span>cMsgGetByteArrayLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArrayLength </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the region-of-interest length of a message's byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">length</td><td>int pointer to be filled with byte array length (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aa2f394c8f794a935d32377cfa4827591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f394c8f794a935d32377cfa4827591">&#9670;&nbsp;</a></span>cMsgGetByteArrayLengthFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArrayLengthFull </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the total length of a message's byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">length</td><td>int pointer to be filled with byte array's total length (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a0c298192a9c6ac566e0a5094c98f68d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c298192a9c6ac566e0a5094c98f68d0">&#9670;&nbsp;</a></span>cMsgGetByteArrayOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetByteArrayOffset </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the region-of-interest offset of a message's byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">offset</td><td>int pointer to be filled with byte array offset index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af00bd9ec9c007d39521250f33fd767a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00bd9ec9c007d39521250f33fd767a5">&#9670;&nbsp;</a></span>cMsgGetConnectState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetConnectState </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>connected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the state of a cMsg connection. If connectState gets filled with a one, there is a valid connection. Anything else (zero in this case), indicates client is not connected. The meaning of "connected" may vary with domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">connected</td><td>integer pointer to be filled in with connection state, (1-connected, 0-unconnected)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgGetConnectState </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="aff1b1b374341bb88557fc26b32c3054c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1b1b374341bb88557fc26b32c3054c">&#9670;&nbsp;</a></span>cMsgGetCurrentUDL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetCurrentUDL </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>udl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the UDL current used in the existing connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">udl</td><td>pointer filled in with current UDL or NULL if no connection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called or udl arg is NULL </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgGetConnectState </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a1820f554cad254ee20a559a409c47725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1820f554cad254ee20a559a409c47725">&#9670;&nbsp;</a></span>cMsgGetDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetDescription </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the client description used in a cMsg connection. If successful, this routine will return a pointer to char inside the system structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">description</td><td>pointer to pointer filled with the description</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_BAD_ARGUMENT if either arg is NULL </dd>
<dd>
CMSG_OK if successful </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a63ecf71837d95900cf511c9d0cd1f397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ecf71837d95900cf511c9d0cd1f397">&#9670;&nbsp;</a></span>cMsgGetDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetDomain </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the domain of a message. When a message is newly created (eg. by <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>), the domain field of a message is not set. In the cMsg domain, the cMsg server sets this field when it receives a client's sent message. Messages received from the server will have this field set. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">domain</td><td>pointer to pointer filled with message's cMsg domain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="abf33e545651c274b2d35d03d33ce7fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf33e545651c274b2d35d03d33ce7fd1">&#9670;&nbsp;</a></span>cMsgGetDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetDouble </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the double given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a1d3342d9b1ebe001d5e8cad17dc3327b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3342d9b1ebe001d5e8cad17dc3327b">&#9670;&nbsp;</a></span>cMsgGetDoubleArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetDoubleArray </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the double array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a998b005eca1705f3d225bc84f08c3857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998b005eca1705f3d225bc84f08c3857">&#9670;&nbsp;</a></span>cMsgGetFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetFloat </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a float of the given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="afb0d17da612a154c619919f0d22c9df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0d17da612a154c619919f0d22c9df4">&#9670;&nbsp;</a></span>cMsgGetFloatArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetFloatArray </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the float array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="ae0e02fcce345ec42440fc3ebc4c8881e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e02fcce345ec42440fc3ebc4c8881e">&#9670;&nbsp;</a></span>cMsgGetGetRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetGetRequest </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>getRequest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the "get request" field of a message. The "get
request" field indicates the message was sent by a sendAndGet call, if it has a value of 1. A value of 0 indicates it was not sent by a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">getRequest</td><td>integer pointer to be filled in with 1 if message sent by a sendAndGet and 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="abdebb7832d494aacecf88ab381af5bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdebb7832d494aacecf88ab381af5bfc">&#9670;&nbsp;</a></span>cMsgGetGetResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetGetResponse </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>getResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the "get response" field of a message. The "get
reponse" field indicates the message is a response to a message sent by a sendAndGet call, if it has a value of 1. A value of 0 indicates it is not a response to a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">getResponse</td><td>integer pointer to be filled in 1 if message is a response to a sendAndGet and 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="adc1e33b4645d96f5746fc496b9dff35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1e33b4645d96f5746fc496b9dff35c">&#9670;&nbsp;</a></span>cMsgGetHistoryLengthMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetHistoryLengthMax </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the maximum number of entries this message keeps of its history of various parameters (sender's name, host, time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">len</td><td>integer pointer to be filled inwith max number of entries this message keeps of its history of various parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a57f251bf48c97c7822b5ca1a91bd620e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f251bf48c97c7822b5ca1a91bd620e">&#9670;&nbsp;</a></span>cMsgGetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInfo </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine does general I/O and returns a string for each string argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">command</td><td>command whose value determines what is returned in string arg </td></tr>
    <tr><td class="paramname">string</td><td>pointer which gets filled in with a return string (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED this routine is not implemented </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ab547c3a8e11197d69b8ace7ebfa53656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab547c3a8e11197d69b8ace7ebfa53656">&#9670;&nbsp;</a></span>cMsgGetInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInt16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 16 bit, signed integer given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="aec1951b19ce69ee490a011f2003da3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1951b19ce69ee490a011f2003da3dc">&#9670;&nbsp;</a></span>cMsgGetInt16Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInt16Array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 16 bit, signed integer array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="ac7fbec1883ddf14631aae471ba127090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fbec1883ddf14631aae471ba127090">&#9670;&nbsp;</a></span>cMsgGetInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInt32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 32 bit, signed integer given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a5b365e48623efcbadab28c3dcd439931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b365e48623efcbadab28c3dcd439931">&#9670;&nbsp;</a></span>cMsgGetInt32Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInt32Array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 32 bit, signed integer array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="acb8e5bac3e395eae7fd35b9ed37b2ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8e5bac3e395eae7fd35b9ed37b2ec1">&#9670;&nbsp;</a></span>cMsgGetInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInt64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 64 bit, signed integer given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a4f847b59d27a6d96a63fe58840955542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f847b59d27a6d96a63fe58840955542">&#9670;&nbsp;</a></span>cMsgGetInt64Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInt64Array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 64 bit, signed integer array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="ad3331b6b38241b598694ac0d3540e05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3331b6b38241b598694ac0d3540e05a">&#9670;&nbsp;</a></span>cMsgGetInt8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInt8 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns an 8 bit, signed integer given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a1dbdb88590b14d9be7feca7dde8c6c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbdb88590b14d9be7feca7dde8c6c78">&#9670;&nbsp;</a></span>cMsgGetInt8Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetInt8Array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns an 8 bit, signed integer array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="abf5d1988c6f449f07df428b7d60d936a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5d1988c6f449f07df428b7d60d936a">&#9670;&nbsp;</a></span>cMsgGetMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the value of the given field as a cMsg message if it exists. Do NOT write into the returned pointer's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="a3ecc3570645ec81d55733aed8c3c6c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecc3570645ec81d55733aed8c3c6c2c">&#9670;&nbsp;</a></span>cMsgGetMessageArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetMessageArray </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void ***&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the value of the given field as an array of cMsg messages if it exists. Do NOT write into the returned pointer's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with array value </td></tr>
    <tr><td class="paramname">len</td><td>pointer to int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="a7c9b5fe19b27451658aefbb62f0f138b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9b5fe19b27451658aefbb62f0f138b">&#9670;&nbsp;</a></span>cMsgGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetName </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the client name used in a cMsg connection. If successful, this routine will return a pointer to char inside the system structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">name</td><td>pointer to pointer filled with the name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_BAD_ARGUMENT if either arg is NULL </dd>
<dd>
CMSG_OK if successful </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a2b25010d5d27303d15288212e018a6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b25010d5d27303d15288212e018a6c2">&#9670;&nbsp;</a></span>cMsgGetNullGetResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetNullGetResponse </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nullGetResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the "NULL get response" field of a message. If it has a value of 1, the "NULL get response" field indicates that if the message is a response to a message sent by a sendAndGet call, when sent it will be received as a NULL pointer - not a message. Any other value indicates it is not a null get response to a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">nullGetResponse</td><td>integer pointer to be filled in with 1 if message is a NULL response to a sendAndGet and 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ae9c0eac1762db63b9e0507ea6204df47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c0eac1762db63b9e0507ea6204df47">&#9670;&nbsp;</a></span>cMsgGetPayloadText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetPayloadText </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>payloadText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the payload text of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">payloadText</td><td>pointer to pointer filled with message's payload text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ab74ea9c810a5e21db3fc7ee2a70c1fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74ea9c810a5e21db3fc7ee2a70c1fdd">&#9670;&nbsp;</a></span>cMsgGetReceiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReceiver </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>receiver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the receiver of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">receiver</td><td>pointer to pointer filled with message's receiver</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af610fc6f5b12d664021f9bbddd83737c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af610fc6f5b12d664021f9bbddd83737c">&#9670;&nbsp;</a></span>cMsgGetReceiverHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReceiverHost </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>receiverHost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the host of the receiver of a message. This field is NULL for a newly created message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">receiverHost</td><td>pointer to pointer filled with host of the message receiver</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a5743b6b3fd75506c9ad40a0e840909d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5743b6b3fd75506c9ad40a0e840909d2">&#9670;&nbsp;</a></span>cMsgGetReceiverTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReceiverTime </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>receiverTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the time a message was received (in seconds since midnight GMT, Jan 1st, 1970).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">receiverTime</td><td>pointer to be filled with time message was received</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a9945b6ed528879a54cbc0611373a8f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9945b6ed528879a54cbc0611373a8f71">&#9670;&nbsp;</a></span>cMsgGetReceiveState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReceiveState </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>receiveState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the message receiving state of a cMsg connection. If receiveState gets filled with a one, all messages sent to the client will be received and sent to appropriate callbacks . Anything else (zero in this case), indicates no messages will be received or sent to callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">receiveState</td><td>integer pointer to be filled in with the receive state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_BAD_ARGUMENT if either arg is NULL </dd>
<dd>
CMSG_OK if successful </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af90345420a9a31829151a88a35f3f5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90345420a9a31829151a88a35f3f5cc">&#9670;&nbsp;</a></span>cMsgGetReliableSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetReliableSend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>boolean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets whether the send will be reliable (default, TCP) or will be allowed to be unreliable (UDP).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">boolean</td><td>int pointer to be filled with 1 if true (TCP), else 0 (UDP)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a0969391dfcd3cd8289eb04fc6399b602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0969391dfcd3cd8289eb04fc6399b602">&#9670;&nbsp;</a></span>cMsgGetSender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSender </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the sender of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">sender</td><td>pointer to pointer filled with message's sender</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aa65857ff0e87362d5098ca5e7c63961d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65857ff0e87362d5098ca5e7c63961d">&#9670;&nbsp;</a></span>cMsgGetSenderHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSenderHost </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>senderHost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the host of the sender of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">senderHost</td><td>pointer to pointer filled with host of the message sender</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ac2d3b1e0b664616cb77b6966e0dce97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d3b1e0b664616cb77b6966e0dce97e">&#9670;&nbsp;</a></span>cMsgGetSenderTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSenderTime </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>senderTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the time a message was last sent (in seconds since midnight GMT, Jan 1st, 1970).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">senderTime</td><td>pointer to be filled with time message was last sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="adb2487f6d2221f988e2b0dca1b3004cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2487f6d2221f988e2b0dca1b3004cd">&#9670;&nbsp;</a></span>cMsgGetServerHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetServerHost </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ipAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the IP address (in dotted-decimal form) that the client used to make the network connection to itsserver. Do NOT write into or free the returned char pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">ipAddress</td><td>pointer filled in with server IP address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED if not implemented in the given domain </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ae0fb1e1c06d2296e4c39e1ef388311c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fb1e1c06d2296e4c39e1ef388311c2">&#9670;&nbsp;</a></span>cMsgGetServerPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetServerPort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the port that the client used to make the network connection to its server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">port</td><td>pointer filled in with server TCP port</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED if not implemented in the given domain </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a9b0f995cbe118bd5a5b3ab1549567ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0f995cbe118bd5a5b3ab1549567ae1">&#9670;&nbsp;</a></span>cMsgGetString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetString </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the value of the given field as a string if it exists. Do NOT write into the returned pointer's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="adfd25e765e52bb1629490b9571a4f222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd25e765e52bb1629490b9571a4f222">&#9670;&nbsp;</a></span>cMsgGetStringArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetStringArray </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char ***&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the string array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">array</td><td>pointer to array of pointers which gets filled with string array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="aebd99fe965b1a18f041853f167e41d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd99fe965b1a18f041853f167e41d67">&#9670;&nbsp;</a></span>cMsgGetSubject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubject </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>subject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the subject of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">subject</td><td>pointer to pointer filled with message's subject</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ad011394994f936cf5e59af00f9522255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad011394994f936cf5e59af00f9522255">&#9670;&nbsp;</a></span>cMsgGetSubscriptionCueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionCueSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the cue size of a callback and is valid only when used in a callback on the message given in the callback argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">size</td><td>pointer which gets filled with a callback's cue size or -1 if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af0144cc0cb39c6a8e1e0d63942a58d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0144cc0cb39c6a8e1e0d63942a58d16">&#9670;&nbsp;</a></span>cMsgGetSubscriptionDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionDomain </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the domain a subscription is running in and is valid only when used in a callback on the message given in the callback argument. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">domain</td><td>pointer to pointer filled with a subscription's domain or NULL if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aa87027a186787990d1494be0efd9bc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87027a186787990d1494be0efd9bc56">&#9670;&nbsp;</a></span>cMsgGetSubscriptionSubject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionSubject </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>subject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the subject a subscription is using and is valid only when used in a callback on the message given in the callback argument. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">subject</td><td>pointer to pointer filled with a subscription's subject or NULL if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="acfe0764303285ec69cbe96b2dfb8a37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe0764303285ec69cbe96b2dfb8a37e">&#9670;&nbsp;</a></span>cMsgGetSubscriptionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the type a subscription is using and is valid only when used in a callback on the message given in the callback argument. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">type</td><td>pointer to pointer filled with a subscription's type or NULL if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a173893c0ea87d53f715dc5d467788b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173893c0ea87d53f715dc5d467788b4e">&#9670;&nbsp;</a></span>cMsgGetSubscriptionUDL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetSubscriptionUDL </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>udl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the udl of a subscription's connection and is valid only when used in a callback on the message given in the callback argument. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">udl</td><td>pointer to pointer filled with the udl of a subscription's connection or NULL if no information is available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a1e6b173d6ee98259bd9e2e3aeb9e1a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6b173d6ee98259bd9e2e3aeb9e1a34">&#9670;&nbsp;</a></span>cMsgGetText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetText </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the text of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">text</td><td>pointer to pointer filled with a message's text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ac5079c24edb7c920c07c6e24c1e4908f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5079c24edb7c920c07c6e24c1e4908f">&#9670;&nbsp;</a></span>cMsgGetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the type of a message. If successful, this routine will return a pointer to char inside the message structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">type</td><td>pointer to pointer filled with message's type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a8900e00f1d6651aa96547b19e2fb0005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8900e00f1d6651aa96547b19e2fb0005">&#9670;&nbsp;</a></span>cMsgGetUDL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUDL </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>udl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the UDL used to establish a cMsg connection. If successful, this routine will return a pointer to char inside the system structure. The user may NOT write to this memory location!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>id of the domain connection </td></tr>
    <tr><td class="paramname">udl</td><td>pointer to pointer filled with the UDL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_BAD_ARGUMENT if either arg is NULL </dd>
<dd>
CMSG_OK if successful </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a1bd5abe308dd88c7cd388eae6440cf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd5abe308dd88c7cd388eae6440cf61">&#9670;&nbsp;</a></span>cMsgGetUint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUint16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 16 bit, unsigned integer given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a1834d0566588ad7008b97c1f968dfc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1834d0566588ad7008b97c1f968dfc75">&#9670;&nbsp;</a></span>cMsgGetUint16Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUint16Array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 16 bit, unsigned integer array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a76c19dd89c67d5b6bf4a58238c5871f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c19dd89c67d5b6bf4a58238c5871f4">&#9670;&nbsp;</a></span>cMsgGetUint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUint32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 32 bit, unsigned integer given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="ab5fa438a529ee9ce27515c303b3082dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fa438a529ee9ce27515c303b3082dc">&#9670;&nbsp;</a></span>cMsgGetUint32Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUint32Array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 32 bit, unsigned integer array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="aabcd01a61333f69ace4eec677bf79cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcd01a61333f69ace4eec677bf79cdc">&#9670;&nbsp;</a></span>cMsgGetUint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUint64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 64 bit, unsigned integer given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="ab8560cd6dce3fe52ae9ccedbfd9ee73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8560cd6dce3fe52ae9ccedbfd9ee73c">&#9670;&nbsp;</a></span>cMsgGetUint64Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUint64Array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a 64 bit, unsigned integer array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a94b28bd9bbb6ad32bbb981c72331e8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b28bd9bbb6ad32bbb981c72331e8e5">&#9670;&nbsp;</a></span>cMsgGetUint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUint8 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns an 8 bit, unsigned integer given field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">val</td><td>pointer filled with field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a48ffbac38eefd3cd901b46d3c651a6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ffbac38eefd3cd901b46d3c651a6e5">&#9670;&nbsp;</a></span>cMsgGetUint8Array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUint8Array </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns an 8 bit, unsigned integer array of the given field if it exists. Do NOT write into the returned array's memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">vals</td><td>pointer filled with field array </td></tr>
    <tr><td class="paramname">len</td><td>pointer int which gets filled with the number of elements in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_FORMAT field is not right type or contains error </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

</div>
</div>
<a id="a77a6252706b0202d3920b8a78d6629f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a6252706b0202d3920b8a78d6629f0">&#9670;&nbsp;</a></span>cMsgGetUserInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUserInt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>userInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets a message's user-defined integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">userInt</td><td>integer pointer to be filled with message's user-defined integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ae709e7079a007ee88ebc0b41a4da8a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae709e7079a007ee88ebc0b41a4da8a7b">&#9670;&nbsp;</a></span>cMsgGetUserTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetUserTime </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>userTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets a message's user-defined time (in seconds since midnight GMT, Jan 1st, 1970).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">userTime</td><td>time_t pointer to be filled with message's user-defined time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ad7995e48e5e280e505e37b4b5b72402c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7995e48e5e280e505e37b4b5b72402c">&#9670;&nbsp;</a></span>cMsgGetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgGetVersion </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the cMsg major version number of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">version</td><td>integer pointer to be filled in with cMsg major version</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a63472f68444bc42795e840b199d6d10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63472f68444bc42795e840b199d6d10e">&#9670;&nbsp;</a></span>cMsgHasPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgHasPayload </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>hasPayload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns whether a message has a compound payload or not. It returns 0 if there is no payload and the number of items in the payload is there is one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">hasPayload</td><td>pointer which gets filled with the number of items if msg has compound payload, else 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../d1/dfc/c_msg_compound_payload_8c.html#a51ed21521fc461afebfdf137a55dd7c3">cMsgPayloadGetCount()</a>.</p>

</div>
</div>
<a id="aae8ef09efaaacfb7c007a8aeead0d103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8ef09efaaacfb7c007a8aeead0d103">&#9670;&nbsp;</a></span>cMsgInitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgInitMessage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initializes a message. It frees all allocated memory, sets all strings to NULL, and sets all numeric values to their default state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message structure being initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if msg is NULL </dd></dl>

</div>
</div>
<a id="aa3bd41627b445c05a91a04e32cc20492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bd41627b445c05a91a04e32cc20492">&#9670;&nbsp;</a></span>cMsgIntChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cMsgIntChars </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a unique string representation of a int in the form of 8 hex chars. String points to allocated memory which needs to be freed by caller to avoid a memory leak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>int value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hex characters rep of 32 bit unsigned int, needs to be freed by caller </dd></dl>

</div>
</div>
<a id="ad01d705dd17d13231b8128c9767311fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01d705dd17d13231b8128c9767311fa">&#9670;&nbsp;</a></span>cMsgMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgMonitor </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>replyMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is a synchronous call to receive a message containing monitoring data which describes the state of the cMsg domain the user is connected to. The time is data was sent can be obtained by calling cMsgGetSenderTime. The monitoring data in xml format can be obtained by calling cMsgGetText.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">command</td><td>string to monitor data collecting routine </td></tr>
    <tr><td class="paramname">replyMsg</td><td>message received from the domain containing monitor data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSendAndGet </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a7679f62347f3d049024cd767da4cbbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7679f62347f3d049024cd767da4cbbcb">&#9670;&nbsp;</a></span>cMsgNeedToSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgNeedToSwap </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method specifies whether the endian value of the byte array is the same value as the local host. If not, a 1 is returned indicating that the data needs to be swapped. If so, a 0 is returned indicating that no swap is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">swap</td><td>int pointer to be filled with 1 if byte array needs swapping, else 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if local endianness is unknown </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1597f0497d2b0a8b2cdbb90763bc81e6">CMSG_ERROR</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="afb257ec2a764410aea07ccfd86841957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb257ec2a764410aea07ccfd86841957">&#9670;&nbsp;</a></span>cMsgPayloadClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgPayloadClear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine removes all the user-added items in the given message's payload. The payload may still contain fields added by the cMsg system. If there are no items left in the payload, this routine is equivalent to <a class="el" href="../../d5/d52/c_msg_8h.html#ac1642a5fbfd664d9a1b813e6eed50282">cMsgPayloadReset</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f8a80b128fc6b33791d50f8dd8a9255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8a80b128fc6b33791d50f8dd8a9255">&#9670;&nbsp;</a></span>cMsgPayloadContainsName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadContainsName </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks to see if a name is already in use by an existing field in the payload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if name does not exist or there is no payload </dd>
<dd>
1 if name exists </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d1/dfc/c_msg_compound_payload_8c.html#a92338cd77d996904f35344a91d38c609">cMsgAddHistoryToPayloadText()</a>.</p>

</div>
</div>
<a id="ac7564ac7969a9e7a82d49e96f756853c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7564ac7969a9e7a82d49e96f756853c">&#9670;&nbsp;</a></span>cMsgPayloadCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadCopy </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsgFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsgTo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine copies the payload from one message to another. The original payload of the "to" message is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsgFrom</td><td>pointer to message to copy payload from </td></tr>
    <tr><td class="paramname">vmsgTo</td><td>pointer to message to copy payload to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either argument is null </dd>
<dd>
CMSG_OUT_OF_MEMORY if operating system out of memory </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="a2f24953e8dafd743f193fd79b6ad944b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f24953e8dafd743f193fd79b6ad944b">&#9670;&nbsp;</a></span>cMsgPayloadFieldDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cMsgPayloadFieldDescription </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a description of the given field name. Do NOT write to this location in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to describe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if no payload exists </dd>
<dd>
field name if field exists </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a9fb482e79bbbf8451164fbe8483388e2">CMSG_CP_BIN</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ab7f13d4e4f34b57217987bf9ddc42045">CMSG_CP_BIN_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a4e1ba4918f448a5e1313f0e1f9e6c92c">CMSG_CP_DBL</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a72af8658ce1cf8dabce41f62a634e1bc">CMSG_CP_DBL_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7afa3b75e5c56bd1a75577e03bebb165c7">CMSG_CP_FLT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a2c95172012d8426114d18042e1b42485">CMSG_CP_FLT_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ae1434d031d2450bf5f5a35ef8056cc08">CMSG_CP_INT16</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a221a99ba6ac8080e39501bea445858a4">CMSG_CP_INT16_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a956323e0ea1b2869a8566a26ebbc850b">CMSG_CP_INT32</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a90bfe616669e8f411cba58ee380c1a97">CMSG_CP_INT32_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a20a6ef1d2c657d6d7cae298e5ee99692">CMSG_CP_INT64</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7af050aea6a85faa613fa74119b5a8e9c5">CMSG_CP_INT64_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a3e22bf9879fbba05eea481bb4c784ce4">CMSG_CP_INT8</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ab6b97ab094a199ec3c0a3371e0054eb4">CMSG_CP_INT8_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a8de20f59ee7ff330c5cef462e78f31de">CMSG_CP_MSG</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ad7c01639a98afae4033945cf66877e24">CMSG_CP_MSG_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a010cfeb3238eda31ae8b4908f09e0aed">CMSG_CP_STR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a0151ef9121dfdcbcbe3274dda16977cb">CMSG_CP_STR_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a138db1971f648c1a1af61f5ad0a5ec8a">CMSG_CP_UINT16</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a5b3670d6eab9aa621b4078ab10a6f1cc">CMSG_CP_UINT16_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a961b7838d40a1acdd3eb615487330655">CMSG_CP_UINT32</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a84813dee5325453895236bfbd7dcc187">CMSG_CP_UINT32_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ac81dcc27b1807c868b035cd0abcaec99">CMSG_CP_UINT64</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a6f1d265ff8754e1832d82221d079989b">CMSG_CP_UINT64_A</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7abb495beda8f5c298e6d6619757d51230">CMSG_CP_UINT8</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a15e5f4bffce8a80c6acffd956adecf0d">CMSG_CP_UINT8_A</a>, and <a class="el" href="../../d1/dfc/c_msg_compound_payload_8c.html#a8873fe9e6fcb574563a90fce2d79db4a">cMsgPayloadGetType()</a>.</p>

</div>
</div>
<a id="a217bc602d56d8b716f01b93aee829821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217bc602d56d8b716f01b93aee829821">&#9670;&nbsp;</a></span>cMsgPayloadGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadGet </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine fills 2 arrays provided by the caller. One contains all the names of the items in the payload, and the second contains the corresponding data types of those items. Each element of the array of characters points to a string in the message itself which must not be freed or written to. The difference between this routine and <a class="el" href="../../d5/d52/c_msg_8h.html#a880746983c824f0f211b457fdabfa781">cMsgPayloadGetInfo</a> is that this routine allocates no memory so nothing needs to be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">names</td><td>pointer which gets filled with the array of names in a payload </td></tr>
    <tr><td class="paramname">types</td><td>pointer to an array of ints which gets filled with type of data associated with each field name in "names" </td></tr>
    <tr><td class="paramname">len</td><td>length of each of the given arrays, if arrays are different lengths give the smallest of the lengths</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload is found </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL or of improper value </dd>
<dd>
CMSG_LIMIT_EXCEEDED if len &lt; the number of items, but len number of valid values are still returned in names and types </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1597f0497d2b0a8b2cdbb90763bc81e6">CMSG_ERROR</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a51ed21521fc461afebfdf137a55dd7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ed21521fc461afebfdf137a55dd7c3">&#9670;&nbsp;</a></span>cMsgPayloadGetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadGetCount </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the number of payload items a message has.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">count</td><td>pointer which gets filled with the number of payload items (0 for no payload)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dfc/c_msg_compound_payload_8c.html#a63472f68444bc42795e840b199d6d10e">cMsgHasPayload()</a>.</p>

</div>
</div>
<a id="a87048a62d5c0eac77232a252fed357c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87048a62d5c0eac77232a252fed357c9">&#9670;&nbsp;</a></span>cMsgPayloadGetFieldText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadGetFieldText </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a pointer to the string representation of the given field. Do NOT write to this location in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field </td></tr>
    <tr><td class="paramname">val</td><td>pointer to pointer which is set to string representation of field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload or field of that name exists </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="a880746983c824f0f211b457fdabfa781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880746983c824f0f211b457fdabfa781">&#9670;&nbsp;</a></span>cMsgPayloadGetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadGetInfo </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns 2 arrays. One contains all the names of the items in the payload, and the second contains the corresponding data types of those items. It also returns the length of both arrays. Both arrays use allocated memory and must be freed by the caller. Each element of the array of characters points to a string in the message itself which must not be freed or written to. The difference between this routine and <a class="el" href="../../d5/d52/c_msg_8h.html#a217bc602d56d8b716f01b93aee829821">cMsgPayloadGet</a> is that the other routine allocates no memory so nothing needs to be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">names</td><td>pointer which gets filled with the array of names in a payload </td></tr>
    <tr><td class="paramname">types</td><td>pointer to an array of ints which gets filled with type of data associated with each field name in "names" </td></tr>
    <tr><td class="paramname">len</td><td>pointer to int which gives the length of the returned arrays</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no payload is found </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1597f0497d2b0a8b2cdbb90763bc81e6">CMSG_ERROR</a>.</p>

</div>
</div>
<a id="a8873fe9e6fcb574563a90fce2d79db4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8873fe9e6fcb574563a90fce2d79db4a">&#9670;&nbsp;</a></span>cMsgPayloadGetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadGetType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the type of data associated with the payload field given by the name argument. The returned type may have the following values: </p><ul>
<li>
CMSG_CP_STR for a String </li>
<li>
CMSG_CP_FLT for a 4 byte float </li>
<li>
CMSG_CP_DBL for an 8 byte float </li>
<li>
CMSG_CP_INT8 for an 8 bit int </li>
<li>
CMSG_CP_INT16 for a 16 bit int </li>
<li>
CMSG_CP_INT32 for a 32 bit int </li>
<li>
CMSG_CP_INT64 for a 64 bit int </li>
<li>
CMSG_CP_UINT8 for an unsigned 8 bit int </li>
<li>
CMSG_CP_UINT16 for an unsigned 16 bit int </li>
<li>
CMSG_CP_UINT32 for an unsigned 32 bit int </li>
<li>
CMSG_CP_UINT64 for an unsigned 64 bit int </li>
<li>
CMSG_CP_MSG for a cMsg message </li>
<li>
<p class="startli">CMSG_CP_BIN for binary</p>
<p class="endli"></p>
</li>
<li>
CMSG_CP_STR_A for a String array </li>
<li>
CMSG_CP_FLT_A for a 4 byte float array </li>
<li>
CMSG_CP_DBL_A for an 8 byte float array </li>
<li>
CMSG_CP_INT8_A for an 8 bit int array </li>
<li>
CMSG_CP_INT16_A for a 16 bit int array </li>
<li>
CMSG_CP_INT32_A for a 32 bit int array </li>
<li>
CMSG_CP_INT64_A for a 64 bit int array </li>
<li>
CMSG_CP_UINT8_A for an unsigned 8 bit int array </li>
<li>
CMSG_CP_UINT16_A for an unsigned 16 bit int array </li>
<li>
CMSG_CP_UINT32_A for an unsigned 32 bit int array </li>
<li>
CMSG_CP_UINT64_A for an unsigned 64 bit int array </li>
<li>
CMSG_CP_MSG_A for a cMsg message array </li>
<li>
CMSG_CP_BIN_A for an array of binary items </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of payload field </td></tr>
    <tr><td class="paramname">type</td><td>pointer to int gets filled with type of data associated with field given by name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if no field of the given name is found </dd>
<dd>
CMSG_BAD_ARGUMENT if any arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dfc/c_msg_compound_payload_8c.html#a2f24953e8dafd743f193fd79b6ad944b">cMsgPayloadFieldDescription()</a>.</p>

</div>
</div>
<a id="a7075e33ab6f0ca3d5806bc73284a5a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7075e33ab6f0ca3d5806bc73284a5a40">&#9670;&nbsp;</a></span>cMsgPayloadPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgPayloadPrint </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine prints out the message payload in a readable form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3845e125913ca2f42afdeaca12cec2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3845e125913ca2f42afdeaca12cec2ff">&#9670;&nbsp;</a></span>cMsgPayloadRemove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadRemove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine removes the named field if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">name</td><td>name of field to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful </dd>
<dd>
0 if no field with that name was found </dd></dl>

</div>
</div>
<a id="ac1642a5fbfd664d9a1b813e6eed50282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1642a5fbfd664d9a1b813e6eed50282">&#9670;&nbsp;</a></span>cMsgPayloadReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgPayloadReset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine resets the payload to its initial condition (no payload). It frees the allocated memory of the given message's entire payload and then initializes the payload components of the message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e0ad36a23bd14777a3e2cdd04aa3045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0ad36a23bd14777a3e2cdd04aa3045">&#9670;&nbsp;</a></span>cMsgPayloadSetAllFieldsFromText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadSetAllFieldsFromText </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine takes a pointer to a string representation of the whole compound payload, including the system (hidden) fields of the message, as it gets sent over the network and converts it into the hidden system fields and payload of the message. This overwrites any existing system fields and payload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">text</td><td>string sent over network to be unmarshalled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if no payload exists or no memory </dd></dl>

</div>
</div>
<a id="a7c8ebe24cd4dfce9270a0a70ff3e77c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8ebe24cd4dfce9270a0a70ff3e77c4">&#9670;&nbsp;</a></span>cMsgPayloadSetFromText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadSetFromText </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine takes a pointer to a string representation of the whole compound payload, including the system (hidden) fields of the message, as it gets sent over the network and converts it into the standard message payload. All system information is ignored. This overwrites any existing payload and skips over any fields with names starting with "cMsg" (as they are reserved for system use).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">text</td><td>string sent over network to be unmarshalled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if no payload exists or no memory </dd></dl>

</div>
</div>
<a id="a9c5c8070ff4c129830269c005fdedff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5c8070ff4c129830269c005fdedff4">&#9670;&nbsp;</a></span>cMsgPayloadSetSystemFieldsFromText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadSetSystemFieldsFromText </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine takes a pointer to a string representation of the whole compound payload, including the system (hidden) fields of the message, as it gets sent over the network and converts it into the hidden system fields of the message. All non-system information is ignored. This overwrites any existing system fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">text</td><td>string sent over network to be unmarshalled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if no payload exists or no memory </dd></dl>

</div>
</div>
<a id="a1194149886832c788ad3e5cec152423a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1194149886832c788ad3e5cec152423a">&#9670;&nbsp;</a></span>cMsgPayloadToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadToString </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noSystemFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine converts the message payload to an XML string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">string</td><td>is pointer to char* that will hold the malloc'd string </td></tr>
    <tr><td class="paramname">binary</td><td>includes binary as ASCII if true, else binary is ignored </td></tr>
    <tr><td class="paramname">compact</td><td>if true (!=0), do not include attributes with null or default integer values </td></tr>
    <tr><td class="paramname">noSystemFields</td><td>if true (!=0), do not include system (metadata) payload fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if internal payload parsing error, or cannot get a payload item's type or count </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

</div>
</div>
<a id="ac7967cb13e1c6be8a7007689ca7f3b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7967cb13e1c6be8a7007689ca7f3b40">&#9670;&nbsp;</a></span>cMsgPayloadUpdateText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgPayloadUpdateText </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine updates the text representation of a message's payload. This routine is used internally and does not need to be called by the cMsg user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if arg is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>.</p>

</div>
</div>
<a id="a1d58e5c65d27d6e17ce11988bbed9ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d58e5c65d27d6e17ce11988bbed9ce6">&#9670;&nbsp;</a></span>cMsgPerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cMsgPerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a string describing the given error condition. It can also print out that same string with printf if the debug level is set to CMSG_DEBUG_ERROR or CMSG_DEBUG_SEVERE by <a class="el" href="../../d6/de2/c_msg_8c.html#ae43c67e4ed6b1f7118344ac9d5321e07">cMsgSetDebugLevel()</a>. The returned string is a static char array. This means it is not thread-safe and will be overwritten on subsequent calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error string </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5d513b47d171cea248637c2bdc139187">CMSG_ABORT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba97992a10e4e87de315036eaf4bb1f417">CMSG_ALREADY_EXISTS</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba6c89f0163243ff7fd28fa67c720c8b7d">CMSG_ALREADY_INIT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba9a8611ce306f93b6b502552f2295dd91">CMSG_BAD_DOMAIN_ID</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba76fc8476f93d9077f8d8163080f67e00">CMSG_BAD_DOMAIN_TYPE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba14dc89eebb9d4dd7f21143a3bd317059">CMSG_BAD_FORMAT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba755629b2e69b7ea10ae88d6986b0987f">CMSG_BAD_MESSAGE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a89a0e60afe8f3466ca2bf73301e72fcd">CMSG_DEBUG_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba2dcef6215c2d469d4f933c20a25f7e9b">CMSG_DIFFERENT_VERSION</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1597f0497d2b0a8b2cdbb90763bc81e6">CMSG_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55badbc882b9a97ab0c75723031541b5a094">CMSG_ILLEGAL_MSGTYPE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba2f2118e2b0bd5cbecad3048eaab44d4d">CMSG_LIMIT_EXCEEDED</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba2ee3ad0143bd2735cf8b5a406716a056">CMSG_LOST_CONNECTION</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae40de1fa5548b83d19a547359fbe8e26">CMSG_NETWORK_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba30d0a946e182b5c1a41912cc854fb31a">CMSG_NO_CLASS_FOUND</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba96b807512052ba091f330d45f63496a1">CMSG_NOT_IMPLEMENTED</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55badb84f7dd84b1990c82b1ce76bf2eb330">CMSG_OUT_OF_MEMORY</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf9fe8371ec9e971ff16d0c8d0e552d52">CMSG_OUT_OF_RANGE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba11bd0dbd03b15e5882267b760bfc4a2c">CMSG_PEND_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba8f96b16dc2a63ad5cd377278ca5e3525">CMSG_SERVER_DIED</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bab90f05cdbd0c81b1e199b4e51e7bf6a3">CMSG_SOCKET_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba907e98122298904b115c92945098b173">CMSG_TIMEOUT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba2b83c4b52e9e825ea375cb0b5ce91721">CMSG_WRONG_DOMAIN_TYPE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4f983976b8a0df0f083421742ea561be">CMSG_WRONG_PASSWORD</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#ae3a5aa8533b31f04c9126398a7be17be">cMsgDebug</a>.</p>

</div>
</div>
<a id="aca2d833b870683ee4c130056f4d12673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2d833b870683ee4c130056f4d12673">&#9670;&nbsp;</a></span>cMsgReceiveStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgReceiveStart </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine enables the receiving of messages and delivery to callbacks. The receiving of messages is disabled by default and must be explicitly enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgReceiveStart </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a1e6e3eb577613c7329f7518e74d0b3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6e3eb577613c7329f7518e74d0b3f7">&#9670;&nbsp;</a></span>cMsgReceiveStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgReceiveStop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine disables the receiving of messages and delivery to callbacks. The receiving of messages is disabled by default. This routine only has an effect when <a class="el" href="../../d6/de2/c_msg_8c.html#aca2d833b870683ee4c130056f4d12673">cMsgReceiveStart()</a> was previously called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgReceiveStop </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a790114f9c2091b5c2ff12774e6790ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790114f9c2091b5c2ff12774e6790ec5">&#9670;&nbsp;</a></span>cMsgReconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgReconnect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine tries to reconnect to the server if a connection is broken. The domainId argument is created by first calling <a class="el" href="../../d6/de2/c_msg_8c.html#acc8551bd36bdc8138c0c9574daa3d1fc">cMsgConnect()</a> and establishing a connection to a cMsg server</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if domainId is bad or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgReconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ae75519fd0576e1cc7ef8ff9eb333b7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75519fd0576e1cc7ef8ff9eb333b7bd">&#9670;&nbsp;</a></span>cMsgResetByteArrayLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgResetByteArrayLength </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine resets the region-of-interest length of a message's byte array to its total length or zero if there is none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ac0e85fe096860040adfeed9a8fffe175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e85fe096860040adfeed9a8fffe175">&#9670;&nbsp;</a></span>cMsgSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends a msg to the specified domain server. It is completely asynchronous and never blocks. The domain may require <a class="el" href="../../d6/de2/c_msg_8c.html#adab9134878cc0058e9ae3128a445ff00">cMsgFlush()</a> to be called to force delivery. The domainId argument is created by calling <a class="el" href="../../d6/de2/c_msg_8c.html#acc8551bd36bdc8138c0c9574daa3d1fc">cMsgConnect()</a> and establishing a connection to a cMsg server. The message to be sent may be created by calling <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>, <a class="el" href="../../d6/de2/c_msg_8c.html#a2f976f80a20b3e5c2a64dd9da0a2648a">cMsgCreateNewMessage()</a>, or <a class="el" href="../../d6/de2/c_msg_8c.html#a77bb3706d4c1cf31e44f1f9f1ccb78de">cMsgCopyMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to a message structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSend </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ad7b774e764c900e8f742102923642950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b774e764c900e8f742102923642950">&#9670;&nbsp;</a></span>cMsgSendAndGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSendAndGet </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sendMsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>replyMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets one message from another cMsg client by sending out an initial message to that responder. It is a synchronous routine that fails when no reply is received with the given timeout. This function can be thought of as a peer-to-peer exchange of messages. One message is sent to all listeners. The first responder to the initial message will have its single response message sent back to the original sender. In the cMsg domain, if there are no subscribers to get the sent message, this routine returns CMSG_OK, but with a NULL message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">sendMsg</td><td>messages to send to all listeners </td></tr>
    <tr><td class="paramname">timeout</td><td>amount of time to wait for the response message </td></tr>
    <tr><td class="paramname">replyMsg</td><td>message received from the responder; may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSendAndGet </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ae7b3d5d8af3c3f81a74ad0e27d74ef8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b3d5d8af3c3f81a74ad0e27d74ef8f">&#9670;&nbsp;</a></span>cMsgSetByteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArray </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a message's byte array by copying "length" number of bytes into a newly allocated array. The offset is reset to 0 while the length is set to the given value. Any pre-existing byte array memory is freed if it was copied into the given message. If the given array is null, the message's byte array is set to null and both offset &amp; length are set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">array</td><td>byte array </td></tr>
    <tr><td class="paramname">length</td><td>number of bytes in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL, or length &lt; 0 </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55badb84f7dd84b1990c82b1ce76bf2eb330">CMSG_OUT_OF_MEMORY</a>.</p>

</div>
</div>
<a id="a549e77f6cc3fd844ecec74185a5c5551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549e77f6cc3fd844ecec74185a5c5551">&#9670;&nbsp;</a></span>cMsgSetByteArrayEndian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArrayEndian </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the endianness of the byte array data. Valid values are: </p><ul>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#a7b3bb11309d92556aa9babb74911b59a">CMSG_ENDIAN_LOCAL</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#aaca852f1a3397a930e3e2ff113770051">CMSG_ENDIAN_NOTLOCAL</a> </li>
<li>
<a class="el" href="../../de/d99/c_msg_constants_8h.html#ad91bcfd44813a809bbf9ad6cf1dcad34">CMSG_ENDIAN_SWITCH</a> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">endian</td><td>byte array's endianness</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if local endianness is unknown </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL, or endian is not equal to either CMSG_ENDIAN_BIG, CMSG_ENDIAN_LITTLE, CMSG_ENDIAN_LOCAL, CMSG_ENDIAN_NOTLOCAL, or CMSG_ENDIAN_SWITCH </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a3a093ec08a00f74b754718789ed9884a">CMSG_ENDIAN_BIG</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#af479e401552681c846025d61e775fe3a">CMSG_ENDIAN_LITTLE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a7b3bb11309d92556aa9babb74911b59a">CMSG_ENDIAN_LOCAL</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#aaca852f1a3397a930e3e2ff113770051">CMSG_ENDIAN_NOTLOCAL</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#ad91bcfd44813a809bbf9ad6cf1dcad34">CMSG_ENDIAN_SWITCH</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1597f0497d2b0a8b2cdbb90763bc81e6">CMSG_ERROR</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a6b957b96d5723aeaae1b63a4075069d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b957b96d5723aeaae1b63a4075069d4">&#9670;&nbsp;</a></span>cMsgSetByteArrayLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArrayLength </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the region-of-interest length of a message's byte array. This may be smaller than the full length of the array if the user is only interested in a portion of the array. If the byte array is null, all non-negative values are accepted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">length</td><td>byte array's length (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_OUT_OF_RANGE if offset + length is beyond array bounds </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL or length &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf9fe8371ec9e971ff16d0c8d0e552d52">CMSG_OUT_OF_RANGE</a>.</p>

</div>
</div>
<a id="af51659c0d03d14d540d426a96e661800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51659c0d03d14d540d426a96e661800">&#9670;&nbsp;</a></span>cMsgSetByteArrayNoCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArrayNoCopy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a message's byte array by copying the array arg pointer but <b>NOT</b> the data pointed to. The length arg sets the total length of the array in bytes. Any pre-existing byte array data is freed if it was copied into the given message. If the given array is null, the message's byte array is set to null and both offset &amp; length are set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">array</td><td>byte array </td></tr>
    <tr><td class="paramname">length</td><td>number of bytes in array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL or length is &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a82750dc5dcbb0630db7b9827190b8833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82750dc5dcbb0630db7b9827190b8833">&#9670;&nbsp;</a></span>cMsgSetByteArrayOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetByteArrayOffset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the region-of-interest offset of a message's byte array. This may be non-zero if the user is only interested in a portion of the array. If the byte array is null, all non-negative values are accepted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">offset</td><td>byte array's offset index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_OUT_OF_RANGE if offset + length is beyond array bounds </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL or offset &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf9fe8371ec9e971ff16d0c8d0e552d52">CMSG_OUT_OF_RANGE</a>.</p>

</div>
</div>
<a id="ae43c67e4ed6b1f7118344ac9d5321e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43c67e4ed6b1f7118344ac9d5321e07">&#9670;&nbsp;</a></span>cMsgSetDebugLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetDebugLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the level of debug output. The argument should be one of:</p>
<ul>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#a9d166359cbaaaaebc9479ca8a9c47db5">CMSG_DEBUG_NONE</a></li>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#a18c7461e1ad40e27d96fbe542f9c1ca2">CMSG_DEBUG_INFO</a></li>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#abd45547509b8dd1eec77a274fb472a94">CMSG_DEBUG_SEVERE</a></li>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#a89a0e60afe8f3466ca2bf73301e72fcd">CMSG_DEBUG_ERROR</a></li>
<li><a class="el" href="../../de/d99/c_msg_constants_8h.html#a6414c8d4a886423bcf9fe63c577a2d5e">CMSG_DEBUG_WARN</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>debug level desired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if debug level is bad </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a89a0e60afe8f3466ca2bf73301e72fcd">CMSG_DEBUG_ERROR</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a18c7461e1ad40e27d96fbe542f9c1ca2">CMSG_DEBUG_INFO</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a9d166359cbaaaaebc9479ca8a9c47db5">CMSG_DEBUG_NONE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#abd45547509b8dd1eec77a274fb472a94">CMSG_DEBUG_SEVERE</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a6414c8d4a886423bcf9fe63c577a2d5e">CMSG_DEBUG_WARN</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#ae3a5aa8533b31f04c9126398a7be17be">cMsgDebug</a>.</p>

</div>
</div>
<a id="a01f219b4ff224c4899ffe2b14941de23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f219b4ff224c4899ffe2b14941de23">&#9670;&nbsp;</a></span>cMsgSetGetResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetGetResponse </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>getResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the "get response" field of a message. The "get
reponse" field indicates the message is a response to a message sent by a sendAndGet call, if it has a value of 1. Any other value indicates it is not a response to a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">getResponse</td><td>set to 1 if message is a response to a sendAndGet, anything else otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message argument is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aca4d353630206fa691bdb413eafe5d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4d353630206fa691bdb413eafe5d35">&#9670;&nbsp;</a></span>cMsgSetHistoryLengthMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetHistoryLengthMax </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the maximum number of entries this message keeps of its history of various parameters (sender's name, host, time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">len</td><td>max number of entries this message keeps of its history of various parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message argument is NULL </dd>
<dd>
CMSG_OUT_OF_RANGE if len &lt; 0 or &gt; CMSG_HISTORY_LENGTH_ABS_MAX </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf9fe8371ec9e971ff16d0c8d0e552d52">CMSG_OUT_OF_RANGE</a>.</p>

</div>
</div>
<a id="a5083e7b37722212b9eb94ff6f13753b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5083e7b37722212b9eb94ff6f13753b3">&#9670;&nbsp;</a></span>cMsgSetNullGetResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetNullGetResponse </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nullGetResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the "null get response" field of a message. If it has a value of 1, the "null get response" field indicates that if the message is a response to a message sent by a sendAndGet call, when sent it will be received as a NULL pointer - not a message. Any other value indicates it is not a null get response to a sendAndGet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">nullGetResponse</td><td>set to 1 if message is a null get response to a sendAndGet, anything else otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message argument is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ad249624d87a7577a8d6fa838278a68e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad249624d87a7577a8d6fa838278a68e0">&#9670;&nbsp;</a></span>cMsgSetReliableSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetReliableSend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>boolean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets whether the send will be reliable (default, TCP) or will be allowed to be unreliable (UDP).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">boolean</td><td>0 if false (use UDP), anything else true (use TCP)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a4fe6ba7c854be09a2362f22eeb44e194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe6ba7c854be09a2362f22eeb44e194">&#9670;&nbsp;</a></span>cMsgSetShutdownHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetShutdownHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a13c894556c5124a6f408f1b5266b414d">cMsgShutdownHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the shutdown handler function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handler</td><td>shutdown handler function </td></tr>
    <tr><td class="paramname">userArg</td><td>argument to shutdown handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgDisconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a890729efc8b63d8af59e54f98298ac3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890729efc8b63d8af59e54f98298ac3c">&#9670;&nbsp;</a></span>cMsgSetSubject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetSubject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the subject of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">subject</td><td>message subject</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a263231aeceba900e26f4b09f7d88f00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263231aeceba900e26f4b09f7d88f00a">&#9670;&nbsp;</a></span>cMsgSetText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetText </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the text of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">text</td><td>message text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a2ed62a8b39b6992c56bf9cdbfb00f80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed62a8b39b6992c56bf9cdbfb00f80f">&#9670;&nbsp;</a></span>cMsgSetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetType </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the type of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">type</td><td>message type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="acd159c1ce8fa48fc9a4d3c4212827324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd159c1ce8fa48fc9a4d3c4212827324">&#9670;&nbsp;</a></span>cMsgSetUDL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetUDL </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>UDL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine resets the UDL (may be a semicolon separated list of single UDLs). If a reconnect is done, the new UDLs will be used in the connection(s).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">UDL</td><td>new UDL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if not successful reading file for configFile domain UDL </dd>
<dd>
CMSG_BAD_FORMAT if configFile domain file contains UDL of configFile domain or if one of the UDLs is not in the correct format </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called or UDL arg has illegal characters or is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd>
<dd>
CMSG_WRONG_DOMAIN_TYPE one of the domains is of the wrong type </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSetUDL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="afc4c719e852b925e02cc43dc0c0a8c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4c719e852b925e02cc43dc0c0a8c3e">&#9670;&nbsp;</a></span>cMsgSetUserInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetUserInt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>userInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a message's user-defined integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">userInt</td><td>message's user-defined integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aaa8bbb7c3868d0b1c53721ea2c48683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8bbb7c3868d0b1c53721ea2c48683a">&#9670;&nbsp;</a></span>cMsgSetUserTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSetUserTime </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>userTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a message's user-defined time (in seconds since midnight GMT, Jan 1st, 1970).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">userTime</td><td>message's user-defined time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="abaa4d67ad8d8fade9360751b919e23be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa4d67ad8d8fade9360751b919e23be">&#9670;&nbsp;</a></span>cMsgShutdownClients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgShutdownClients </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to shutdown the given clients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">client</td><td>client(s) to be shutdown </td></tr>
    <tr><td class="paramname">flag</td><td>flag describing the mode of shutdown: 0 to not include self, CMSG_SHUTDOWN_INCLUDE_ME to include self in shutdown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED if the subdomain used does NOT implement shutdown </dd>
<dd>
CMSG_NETWORK_ERROR if error in communicating with the server </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called or flag argument improper value </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgDisconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#aa90393045b767904855c0ae31b793c96">CMSG_SHUTDOWN_INCLUDE_ME</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ab7417c11023fa420004ba20da9b710bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7417c11023fa420004ba20da9b710bc">&#9670;&nbsp;</a></span>cMsgShutdownServers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgShutdownServers </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to shutdown the given servers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">server</td><td>server(s) to be shutdown </td></tr>
    <tr><td class="paramname">flag</td><td>flag describing the mode of shutdown: 0 to not include self, CMSG_SHUTDOWN_INCLUDE_ME to include self in shutdown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_IMPLEMENTED if the subdomain used does NOT implement shutdown </dd>
<dd>
CMSG_NETWORK_ERROR if error in communicating with the server </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called or flag argument improper value </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgDisconnect </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#aa90393045b767904855c0ae31b793c96">CMSG_SHUTDOWN_INCLUDE_ME</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a5d422d9f2f693414868af48a16d13649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d422d9f2f693414868af48a16d13649">&#9670;&nbsp;</a></span>cMsgSubscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribe </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2a5df4825a5a9beee6877d4e3c96f491">cMsgCallbackFunc</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine subscribes to messages of the given subject and type. When a message is received, the given callback is passed the message pointer and the userArg pointer and then is executed. A configuration structure is given to determine the behavior of the callback. Only 1 subscription for a specific combination of subject, type, callback and userArg is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">subject</td><td>subject of messages subscribed to </td></tr>
    <tr><td class="paramname">type</td><td>type of messages subscribed to </td></tr>
    <tr><td class="paramname">callback</td><td>pointer to callback to be executed on receipt of message </td></tr>
    <tr><td class="paramname">userArg</td><td>user-specified pointer to be passed to the callback </td></tr>
    <tr><td class="paramname">config</td><td>pointer to callback configuration structure </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to handle (void pointer) to be used for unsubscribing from this subscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscribe </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a7a497a089d800a0fb05a27d3e736e8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a497a089d800a0fb05a27d3e736e8c1">&#9670;&nbsp;</a></span>cMsgSubscribeAndGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeAndGet </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>replyMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets one message from a one-time subscription to the given subject and type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">subject</td><td>subject of message subscribed to </td></tr>
    <tr><td class="paramname">type</td><td>type of message subscribed to </td></tr>
    <tr><td class="paramname">timeout</td><td>amount of time to wait for the message </td></tr>
    <tr><td class="paramname">replyMsg</td><td>message received</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSendAndGet </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="abc4d0b394963dec7f2c61111d0c0568e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d0b394963dec7f2c61111d0c0568e">&#9670;&nbsp;</a></span>cMsgSubscribeConfigCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a>* cMsgSubscribeConfigCreate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine creates a structure of configuration information used to determine the behavior of a <a class="el" href="../../d6/de2/c_msg_8c.html#a5d422d9f2f693414868af48a16d13649">cMsgSubscribe()</a>'s callback. The configuration is filled with default values. Each aspect of the configuration may be modified by setter and getter functions. The defaults are:</p><ul>
<li>maximum messages to cue for callback is 10000</li>
<li>no messages may be skipped</li>
<li>calls to the callback function must be serialized</li>
<li>may skip up to 2000 messages at once if skipping is enabled</li>
<li>maximum number of threads when parallelizing calls to the callback function is 100</li>
<li>enough worker threads are started so that there are at most 150 unprocessed messages for each thread</li>
</ul>
<p>Note that this routine allocates memory and <a class="el" href="../../d6/de2/c_msg_8c.html#a9d045c6bbb85efe3e94227acc1153072">cMsgSubscribeConfigDestroy()</a> must be called to free it.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if no memory available </dd>
<dd>
pointer to configuration if successful </dd></dl>

</div>
</div>
<a id="a9d045c6bbb85efe3e94227acc1153072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d045c6bbb85efe3e94227acc1153072">&#9670;&nbsp;</a></span>cMsgSubscribeConfigDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeConfigDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine frees the memory associated with a configuration created by <a class="el" href="../../d6/de2/c_msg_8c.html#abc4d0b394963dec7f2c61111d0c0568e">cMsgSubscribeConfigCreate()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a6a1805ff17bd33dfb0a93049417d07bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1805ff17bd33dfb0a93049417d07bb">&#9670;&nbsp;</a></span>cMsgSubscribeGetMaxCueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMaxCueSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets a subscribe configuration's maximum message cue size. Messages are kept in the cue until they can be processed by the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>integer pointer to be filled with configuration's maximum cue size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a7dc108298020f8e3c71ff33f7a96d3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc108298020f8e3c71ff33f7a96d3b2">&#9670;&nbsp;</a></span>cMsgSubscribeGetMaxThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMaxThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the maximum number of threads a parallelized subscribe's callback can run at once. This setting is only used if <a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize()</a> was called with an argument of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">threads</td><td>integer pointer to be filled with the maximum number of threads a parallelized subscribe's callback can run at once</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a2bed7080ef38765b1d68ef8740aedb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bed7080ef38765b1d68ef8740aedb11">&#9670;&nbsp;</a></span>cMsgSubscribeGetMaySkip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMaySkip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maySkip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets whether messages may be skipped over (deleted) if too many messages are piling up in the cue. The maximum number of messages skipped at once is determined by <a class="el" href="../../d6/de2/c_msg_8c.html#a7da5fb98446bf42337fdaf4a11414929">cMsgSubscribeSetSkipSize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">maySkip</td><td>integer pointer to be filled with 0 if messages may NOT be skipped (deleted), or anything else otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="afe1e8922c48e59728cccf3d042b04f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1e8922c48e59728cccf3d042b04f56">&#9670;&nbsp;</a></span>cMsgSubscribeGetMessagesPerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMessagesPerThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>mpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the maximum number of unprocessed messages per thread before a new thread is started, if a callback is parallelized (<a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize()</a> set to 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">mpt</td><td>integer pointer to be filled with the maximum number of unprocessed messages per thread before starting another thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a8b9415e46ee1b516b010cf5eef28666c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9415e46ee1b516b010cf5eef28666c">&#9670;&nbsp;</a></span>cMsgSubscribeGetMustSerialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetMustSerialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>serialize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets whether a subscribe's callback must be run serially (in one thread), or may be parallelized (run simultaneously in more than one thread) if more than 1 message is waiting in the cue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">serialize</td><td>integer pointer to be filled with 0 if callback may be parallelized, or anything else if callback must be serialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a12842dac9c2dadf7d7713a85b7b28f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12842dac9c2dadf7d7713a85b7b28f88">&#9670;&nbsp;</a></span>cMsgSubscribeGetSkipSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetSkipSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the number of messages to skip over (delete) if too many messages are piling up in the cue. Messages are only skipped if <a class="el" href="../../d6/de2/c_msg_8c.html#a529a2d3840fa660988641dc5b197cc44">cMsgSubscribeSetMaySkip()</a> sets the configuration to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>integer pointer to be filled with the number of messages to skip (delete)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a0ddeab46092de2ccb0e84eacab7046dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddeab46092de2ccb0e84eacab7046dd">&#9670;&nbsp;</a></span>cMsgSubscribeGetStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeGetStackSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine gets the stack size in bytes of the subscription thread. By default the stack size is unspecified (returns 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>pointer to be filled with the stack size in bytes of subscription thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="ae47b52751025fdb3588d2947b085eb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47b52751025fdb3588d2947b085eb3e">&#9670;&nbsp;</a></span>cMsgSubscribeSetMaxCueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMaxCueSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets a subscribe configuration's maximum message cue size. Messages are kept in the cue until they can be processed by the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>maximum cue size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or size &lt; 1 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a69abb5bcff7d143799192fb12646de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69abb5bcff7d143799192fb12646de06">&#9670;&nbsp;</a></span>cMsgSubscribeSetMaxThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMaxThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the maximum number of threads a parallelized subscribe's callback can run at once. This setting is only used if <a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize()</a> was called with an argument of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">threads</td><td>the maximum number of threads a parallelized subscribe's callback can run at once</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or threads &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a529a2d3840fa660988641dc5b197cc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529a2d3840fa660988641dc5b197cc44">&#9670;&nbsp;</a></span>cMsgSubscribeSetMaySkip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMaySkip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maySkip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets whether messages may be skipped over (deleted) if too many messages are piling up in the cue. The maximum number of messages skipped at once is determined by <a class="el" href="../../d6/de2/c_msg_8c.html#a7da5fb98446bf42337fdaf4a11414929">cMsgSubscribeSetSkipSize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">maySkip</td><td>set to 0 if messages may NOT be skipped, set to anything else otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aac01109573ba8542848272978e0c627c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac01109573ba8542848272978e0c627c">&#9670;&nbsp;</a></span>cMsgSubscribeSetMessagesPerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMessagesPerThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the maximum number of unprocessed messages per thread before a new thread is started, if a callback is parallelized (<a class="el" href="../../d6/de2/c_msg_8c.html#aea52cae1f0be6c43c9f491c6a7128db0">cMsgSubscribeSetMustSerialize()</a> set to 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">mpt</td><td>set to maximum number of unprocessed messages per thread before starting another thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or mpt &lt; 1 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="aea52cae1f0be6c43c9f491c6a7128db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea52cae1f0be6c43c9f491c6a7128db0">&#9670;&nbsp;</a></span>cMsgSubscribeSetMustSerialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetMustSerialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>serialize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets whether a subscribe's callback must be run serially (in one thread), or may be parallelized (run simultaneously in more than one thread) if more than 1 message is waiting in the cue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">serialize</td><td>set to 0 if callback may be parallelized, or set to anything else if callback must be serialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a7da5fb98446bf42337fdaf4a11414929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da5fb98446bf42337fdaf4a11414929">&#9670;&nbsp;</a></span>cMsgSubscribeSetSkipSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetSkipSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the number of messages to skip over (delete) if too many messages are piling up in the cue. Messages are only skipped if <a class="el" href="../../d6/de2/c_msg_8c.html#a529a2d3840fa660988641dc5b197cc44">cMsgSubscribeSetMaySkip()</a> sets the configuration to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>number of messages to skip (delete)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or size &lt; 0 </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="af4d900c90f49e384fe2b8133f6db0a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d900c90f49e384fe2b8133f6db0a37">&#9670;&nbsp;</a></span>cMsgSubscribeSetStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscribeSetStackSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d52/c_msg_8h.html#a2df480a6bce32c360ad07d5e35e3b5c9">cMsgSubscribeConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sets the stack size in bytes of the subscription thread. By default the stack size is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to configuration </td></tr>
    <tr><td class="paramname">size</td><td>stack size in bytes of subscription thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_NOT_INITIALIZED if configuration was not initialized </dd>
<dd>
CMSG_BAD_ARGUMENT if configuration is NULL or size &lt; 1 byte </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55baecc113a31f8407cd4c705e60741ece8b">CMSG_NOT_INITIALIZED</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
<a id="a249f6269c777aacf10732643d1d3ecc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249f6269c777aacf10732643d1d3ecc7">&#9670;&nbsp;</a></span>cMsgSubscriptionMessagesTotal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionMessagesTotal </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the total number of messages sent to a subscription callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe </td></tr>
    <tr><td class="paramname">total</td><td>int pointer filled in with total number of messages sent to a subscription callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a267a55c66e6d13123ffc0dbcd6b541d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267a55c66e6d13123ffc0dbcd6b541d4">&#9670;&nbsp;</a></span>cMsgSubscriptionPause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionPause </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine pauses the delivery of messages to the given subscription callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
CMSG_NOT_IMPLEMENTED if the subdomain used does NOT implement this function </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="ab20b7dedc9fe1cea771b46d6ac33c237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20b7dedc9fe1cea771b46d6ac33c237">&#9670;&nbsp;</a></span>cMsgSubscriptionQueueClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionQueueClear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine clears a subscription callback's queue of all messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if the id/handle is bad or handle is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a536677299fa10fc48bbcda4870ca441c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536677299fa10fc48bbcda4870ca441c">&#9670;&nbsp;</a></span>cMsgSubscriptionQueueCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionQueueCount </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the number of messages currently in a subscription callback's queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe </td></tr>
    <tr><td class="paramname">count</td><td>int pointer filled in with number of messages in subscription callback queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a78c6442b2ebbc21f2e03e46722117c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c6442b2ebbc21f2e03e46722117c5f">&#9670;&nbsp;</a></span>cMsgSubscriptionQueueIsFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionQueueIsFull </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns true(1) if a subscription callback's queue is full, else false(0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe </td></tr>
    <tr><td class="paramname">full</td><td>int pointer filled in with 1 if subscription callback queue full, else 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a07ee2459ff5f317674b7ea9e8df34d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ee2459ff5f317674b7ea9e8df34d0a">&#9670;&nbsp;</a></span>cMsgSubscriptionResume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSubscriptionResume </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine resumes the delivery of messages to the given subscription callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
CMSG_NOT_IMPLEMENTED if the subdomain used does NOT implement this function </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSubscriptionPause </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a3e6d501ff5422314b650bd8c55f6f800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6d501ff5422314b650bd8c55f6f800">&#9670;&nbsp;</a></span>cMsgSyncSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgSyncSend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends a msg to the specified domain server and receives a response. It is a synchronous routine and as a result blocks until it receives a status integer from the cMsg server. The domainId argument is created by calling <a class="el" href="../../d6/de2/c_msg_8c.html#acc8551bd36bdc8138c0c9574daa3d1fc">cMsgConnect()</a> and establishing a connection to a cMsg server. The message to be sent may be created by calling <a class="el" href="../../d6/de2/c_msg_8c.html#a06e3ca9feea4b9cdd4f5d5bc144b57ce">cMsgCreateMessage()</a>, <a class="el" href="../../d6/de2/c_msg_8c.html#a2f976f80a20b3e5c2a64dd9da0a2648a">cMsgCreateNewMessage()</a>, or <a class="el" href="../../d6/de2/c_msg_8c.html#a77bb3706d4c1cf31e44f1f9f1ccb78de">cMsgCopyMessage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to a message structure </td></tr>
    <tr><td class="paramname">timeout</td><td>amount of time to wait for the response </td></tr>
    <tr><td class="paramname">response</td><td>integer pointer that gets filled with the response</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgSyncSend </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a870e71bbd742cc544d3f137712af7063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870e71bbd742cc544d3f137712af7063">&#9670;&nbsp;</a></span>cMsgToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgToString </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine converts the message to an XML string. Everything is displayed including binary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">string</td><td>is pointer to char* that will hold the malloc'd string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if internal payload parsing error, or cannot get a payload item's type or count </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

</div>
</div>
<a id="acdd12211e4b81a12bedfa8faa0fb862e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd12211e4b81a12bedfa8faa0fb862e">&#9670;&nbsp;</a></span>cMsgToString2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgToString2 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noSystemFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine converts the message to an XML string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">string</td><td>is pointer to char* that will hold the malloc'd string </td></tr>
    <tr><td class="paramname">binary</td><td>includes binary as ASCII if true, else binary is ignored </td></tr>
    <tr><td class="paramname">compact</td><td>if true (!=0), do not include attributes with null or default integer values </td></tr>
    <tr><td class="paramname">noSystemFields</td><td>if true (!=0), do not include system (metadata) payload fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_ERROR if internal payload parsing error, or cannot get a payload item's type or count </dd>
<dd>
CMSG_BAD_ARGUMENT if message is NULL </dd>
<dd>
CMSG_OUT_OF_MEMORY if out of memory </dd></dl>

</div>
</div>
<a id="a04b867224188eca1aa6f9c61ba868adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b867224188eca1aa6f9c61ba868adb">&#9670;&nbsp;</a></span>cMsgTrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgTrim </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routine to trim white space from front and back of given string. Changes made to argument string in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be trimmed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1726f9ebefe2199ac38a60e35e0e1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1726f9ebefe2199ac38a60e35e0e1c7">&#9670;&nbsp;</a></span>cMsgTrimChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgTrimChar </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trimChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routine to trim a given character from front and back of given string. Changes made to argument string in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be trimmed </td></tr>
    <tr><td class="paramname">trimChar</td><td>character to be trimmed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0620f042ef32f864ed34dd47b9531ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0620f042ef32f864ed34dd47b9531ea7">&#9670;&nbsp;</a></span>cMsgTrimDoubleChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMsgTrimDoubleChars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trimChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routine to eliminate contiguous occurrences of a given character in given string. Changes made to argument string in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be trimmed </td></tr>
    <tr><td class="paramname">trimChar</td><td>character to be trimmed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1dab146eac57f2bd20f79628336c28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dab146eac57f2bd20f79628336c28b">&#9670;&nbsp;</a></span>cMsgUnSubscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgUnSubscribe </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine unsubscribes to messages of the given handle (which represents a given subject, type, callback, and user argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>domain connection id </td></tr>
    <tr><td class="paramname">handle</td><td>void pointer obtained from cMsgSubscribe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if bad domainId or <a class="el" href="../../d6/de2/c_msg_8c.html#a86b9114fb29704d0e2d64c22e6287adc">cMsgDisconnect()</a> already called </dd>
<dd>
any errors returned from the actual domain dependent implemenation of cMsgUnSubscribe </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../d6/de2/c_msg_8c.html#a88ac8658ddc9211f67247f7e72c1950c">LOCAL_ARRAY_SIZE</a>.</p>

</div>
</div>
<a id="a375ef62e93bf9feb7195abd9257d11bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375ef62e93bf9feb7195abd9257d11bb">&#9670;&nbsp;</a></span>cMsgWasSent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cMsgWasSent </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>hasBeenSent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns whether a message has been sent over the wire or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmsg</td><td>pointer to message </td></tr>
    <tr><td class="paramname">hasBeenSent</td><td>pointer which gets filled with 1 if msg has been sent, else 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CMSG_OK if successful </dd>
<dd>
CMSG_BAD_ARGUMENT if either arg is NULL </dd></dl>

<p class="reference">References <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba5540dc98cb28540b28280625e03f2612">CMSG_BAD_ARGUMENT</a>, and <a class="el" href="../../de/d99/c_msg_constants_8h.html#a06fc87d81c62e9abb8790b6e5713c55bae9af2881a3de4a3ad9e4945584a6af06">CMSG_OK</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_5809eee9415059aec03c0088f91a79db.html">libsrc</a></li><li class="navelem"><a class="el" href="../../d5/d52/c_msg_8h.html">cMsg.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
